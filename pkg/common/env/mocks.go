// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/common/env/interfaces.go

// Package env provides mocks for all environment interfaces
package env

import (
	"sync"
	"time"
)

// MockEnvironment is a mock implementation of Environment interface
type MockEnvironment struct {
	mu    sync.RWMutex
	vars  map[string]string
	calls map[string]int
}

// NewMockEnvironment creates a new mock environment
func NewMockEnvironment() *MockEnvironment {
	return &MockEnvironment{
		vars:  make(map[string]string),
		calls: make(map[string]int),
	}
}

// Get implements Environment.Get
func (m *MockEnvironment) Get(key string) string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Get"]++
	return m.vars[key]
}

// Set implements Environment.Set
func (m *MockEnvironment) Set(key, value string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Set"]++
	m.vars[key] = value
	return nil
}

// Unset implements Environment.Unset
func (m *MockEnvironment) Unset(key string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Unset"]++
	delete(m.vars, key)
	return nil
}

// Exists implements Environment.Exists
func (m *MockEnvironment) Exists(key string) bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Exists"]++
	_, exists := m.vars[key]
	return exists
}

// GetString implements Environment.GetString
func (m *MockEnvironment) GetString(key, defaultValue string) string {
	m.calls["GetString"]++
	if value := m.Get(key); value != "" {
		return value
	}
	return defaultValue
}

// GetWithDefault implements Environment.GetWithDefault
func (m *MockEnvironment) GetWithDefault(key, defaultValue string) string {
	return m.GetString(key, defaultValue)
}

// GetBool implements Environment.GetBool
func (m *MockEnvironment) GetBool(key string, defaultValue bool) bool {
	m.calls["GetBool"]++
	value := m.Get(key)
	if value == "" {
		return defaultValue
	}
	return value == "true" || value == "1"
}

// GetInt implements Environment.GetInt
func (m *MockEnvironment) GetInt(key string, defaultValue int) int {
	m.calls["GetInt"]++
	// Simplified implementation
	return defaultValue
}

// GetInt64 implements Environment.GetInt64
func (m *MockEnvironment) GetInt64(key string, defaultValue int64) int64 {
	m.calls["GetInt64"]++
	return defaultValue
}

// GetFloat64 implements Environment.GetFloat64
func (m *MockEnvironment) GetFloat64(key string, defaultValue float64) float64 {
	m.calls["GetFloat64"]++
	return defaultValue
}

// GetDuration implements Environment.GetDuration
func (m *MockEnvironment) GetDuration(key string, defaultValue time.Duration) time.Duration {
	m.calls["GetDuration"]++
	return defaultValue
}

// GetStringSlice implements Environment.GetStringSlice
func (m *MockEnvironment) GetStringSlice(key string, defaultValue []string) []string {
	m.calls["GetStringSlice"]++
	return defaultValue
}

// GetWithPrefix implements Environment.GetWithPrefix
func (m *MockEnvironment) GetWithPrefix(prefix string) map[string]string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["GetWithPrefix"]++
	
	result := make(map[string]string)
	for k, v := range m.vars {
		if len(k) >= len(prefix) && k[:len(prefix)] == prefix {
			result[k] = v
		}
	}
	return result
}

// SetMultiple implements Environment.SetMultiple
func (m *MockEnvironment) SetMultiple(vars map[string]string) error {
	m.calls["SetMultiple"]++
	for k, v := range vars {
		m.Set(k, v)
	}
	return nil
}

// GetAll implements Environment.GetAll
func (m *MockEnvironment) GetAll() map[string]string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["GetAll"]++
	
	result := make(map[string]string)
	for k, v := range m.vars {
		result[k] = v
	}
	return result
}

// Clear implements Environment.Clear
func (m *MockEnvironment) Clear() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Clear"]++
	m.vars = make(map[string]string)
	return nil
}

// Validate implements Environment.Validate
func (m *MockEnvironment) Validate(key string, validator func(string) bool) bool {
	m.calls["Validate"]++
	return validator(m.Get(key))
}

// Required implements Environment.Required
func (m *MockEnvironment) Required(keys ...string) error {
	m.calls["Required"]++
	for _, key := range keys {
		if !m.Exists(key) || m.Get(key) == "" {
			return &ValidationError{
				Key:     key,
				Message: "required variable not set",
			}
		}
	}
	return nil
}

// GetCallCount returns the number of times a method was called
func (m *MockEnvironment) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockPathResolver is a mock implementation of PathResolver interface
type MockPathResolver struct {
	calls   map[string]int
	paths   map[string]string
	mu      sync.RWMutex
}

// NewMockPathResolver creates a new mock path resolver
func NewMockPathResolver() *MockPathResolver {
	return &MockPathResolver{
		calls: make(map[string]int),
		paths: make(map[string]string),
	}
}

// SetPath sets a mock path for testing
func (m *MockPathResolver) SetPath(key, path string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.paths[key] = path
}

// Home implements PathResolver.Home
func (m *MockPathResolver) Home() string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Home"]++
	if path, ok := m.paths["home"]; ok {
		return path
	}
	return "/mock/home"
}

// ConfigDir implements PathResolver.ConfigDir
func (m *MockPathResolver) ConfigDir(appName string) string {
	m.calls["ConfigDir"]++
	return "/mock/config/" + appName
}

// DataDir implements PathResolver.DataDir
func (m *MockPathResolver) DataDir(appName string) string {
	m.calls["DataDir"]++
	return "/mock/data/" + appName
}

// CacheDir implements PathResolver.CacheDir
func (m *MockPathResolver) CacheDir(appName string) string {
	m.calls["CacheDir"]++
	return "/mock/cache/" + appName
}

// TempDir implements PathResolver.TempDir
func (m *MockPathResolver) TempDir() string {
	m.calls["TempDir"]++
	return "/mock/tmp"
}

// WorkingDir implements PathResolver.WorkingDir
func (m *MockPathResolver) WorkingDir() string {
	m.calls["WorkingDir"]++
	return "/mock/work"
}

// GOPATH implements PathResolver.GOPATH
func (m *MockPathResolver) GOPATH() string {
	m.calls["GOPATH"]++
	return "/mock/go"
}

// GOROOT implements PathResolver.GOROOT
func (m *MockPathResolver) GOROOT() string {
	m.calls["GOROOT"]++
	return "/mock/goroot"
}

// GOCACHE implements PathResolver.GOCACHE
func (m *MockPathResolver) GOCACHE() string {
	m.calls["GOCACHE"]++
	return "/mock/gocache"
}

// GOMODCACHE implements PathResolver.GOMODCACHE
func (m *MockPathResolver) GOMODCACHE() string {
	m.calls["GOMODCACHE"]++
	return "/mock/gomodcache"
}

// Expand implements PathResolver.Expand
func (m *MockPathResolver) Expand(path string) string {
	m.calls["Expand"]++
	return path
}

// Resolve implements PathResolver.Resolve
func (m *MockPathResolver) Resolve(path string) (string, error) {
	m.calls["Resolve"]++
	return path, nil
}

// IsAbsolute implements PathResolver.IsAbsolute
func (m *MockPathResolver) IsAbsolute(path string) bool {
	m.calls["IsAbsolute"]++
	return path[0] == '/'
}

// MakeAbsolute implements PathResolver.MakeAbsolute
func (m *MockPathResolver) MakeAbsolute(path string) (string, error) {
	m.calls["MakeAbsolute"]++
	if m.IsAbsolute(path) {
		return path, nil
	}
	return "/mock/work/" + path, nil
}

// Clean implements PathResolver.Clean
func (m *MockPathResolver) Clean(path string) string {
	m.calls["Clean"]++
	return path
}

// EnsureDir implements PathResolver.EnsureDir
func (m *MockPathResolver) EnsureDir(path string) error {
	m.calls["EnsureDir"]++
	return nil
}

// EnsureDirWithMode implements PathResolver.EnsureDirWithMode
func (m *MockPathResolver) EnsureDirWithMode(path string, mode uint32) error {
	m.calls["EnsureDirWithMode"]++
	return nil
}

// GetCallCount returns the number of times a method was called
func (m *MockPathResolver) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockEnvManager is a mock implementation of EnvManager interface
type MockEnvManager struct {
	scopes []EnvScope
	calls  map[string]int
	mu     sync.RWMutex
}

// NewMockEnvManager creates a new mock environment manager
func NewMockEnvManager() *MockEnvManager {
	return &MockEnvManager{
		scopes: make([]EnvScope, 0),
		calls:  make(map[string]int),
	}
}

// PushScope implements EnvManager.PushScope
func (m *MockEnvManager) PushScope() EnvScope {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["PushScope"]++
	
	scope := NewMockEnvScope()
	m.scopes = append(m.scopes, scope)
	return scope
}

// PopScope implements EnvManager.PopScope
func (m *MockEnvManager) PopScope() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["PopScope"]++
	
	if len(m.scopes) == 0 {
		return &ValidationError{Message: "no scopes to pop"}
	}
	m.scopes = m.scopes[:len(m.scopes)-1]
	return nil
}

// WithScope implements EnvManager.WithScope
func (m *MockEnvManager) WithScope(fn func(EnvScope) error) error {
	m.calls["WithScope"]++
	scope := m.PushScope()
	defer m.PopScope()
	return fn(scope)
}

// SaveContext implements EnvManager.SaveContext
func (m *MockEnvManager) SaveContext() (EnvContext, error) {
	m.calls["SaveContext"]++
	return NewMockEnvContext(), nil
}

// RestoreContext implements EnvManager.RestoreContext
func (m *MockEnvManager) RestoreContext(ctx EnvContext) error {
	m.calls["RestoreContext"]++
	return nil
}

// Isolate implements EnvManager.Isolate
func (m *MockEnvManager) Isolate(vars map[string]string, fn func() error) error {
	m.calls["Isolate"]++
	return fn()
}

// Fork implements EnvManager.Fork
func (m *MockEnvManager) Fork() EnvManager {
	m.calls["Fork"]++
	return NewMockEnvManager()
}

// GetCallCount returns the number of times a method was called
func (m *MockEnvManager) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockEnvScope is a mock implementation of EnvScope interface
type MockEnvScope struct {
	*MockEnvironment
	changes map[string]EnvChange
	calls   map[string]int
	mu      sync.RWMutex
}

// NewMockEnvScope creates a new mock environment scope
func NewMockEnvScope() *MockEnvScope {
	return &MockEnvScope{
		MockEnvironment: NewMockEnvironment(),
		changes:         make(map[string]EnvChange),
		calls:           make(map[string]int),
	}
}

// Commit implements EnvScope.Commit
func (m *MockEnvScope) Commit() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Commit"]++
	m.changes = make(map[string]EnvChange)
	return nil
}

// Rollback implements EnvScope.Rollback
func (m *MockEnvScope) Rollback() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Rollback"]++
	m.changes = make(map[string]EnvChange)
	return nil
}

// Changes implements EnvScope.Changes
func (m *MockEnvScope) Changes() map[string]EnvChange {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Changes"]++
	
	result := make(map[string]EnvChange)
	for k, v := range m.changes {
		result[k] = v
	}
	return result
}

// HasChanges implements EnvScope.HasChanges
func (m *MockEnvScope) HasChanges() bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["HasChanges"]++
	return len(m.changes) > 0
}

// MockEnvContext is a mock implementation of EnvContext interface
type MockEnvContext struct {
	timestamp time.Time
	variables map[string]string
	calls     map[string]int
	mu        sync.RWMutex
}

// NewMockEnvContext creates a new mock environment context
func NewMockEnvContext() *MockEnvContext {
	return &MockEnvContext{
		timestamp: time.Now(),
		variables: make(map[string]string),
		calls:     make(map[string]int),
	}
}

// Timestamp implements EnvContext.Timestamp
func (m *MockEnvContext) Timestamp() time.Time {
	m.calls["Timestamp"]++
	return m.timestamp
}

// Variables implements EnvContext.Variables
func (m *MockEnvContext) Variables() map[string]string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Variables"]++
	
	result := make(map[string]string)
	for k, v := range m.variables {
		result[k] = v
	}
	return result
}

// Count implements EnvContext.Count
func (m *MockEnvContext) Count() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Count"]++
	return len(m.variables)
}

// Diff implements EnvContext.Diff
func (m *MockEnvContext) Diff(other EnvContext) map[string]EnvChange {
	m.calls["Diff"]++
	return make(map[string]EnvChange)
}

// Merge implements EnvContext.Merge
func (m *MockEnvContext) Merge(other EnvContext) EnvContext {
	m.calls["Merge"]++
	return NewMockEnvContext()
}

// Export implements EnvContext.Export
func (m *MockEnvContext) Export() map[string]string {
	m.calls["Export"]++
	return m.Variables()
}

// MockEnvValidator is a mock implementation of EnvValidator interface
type MockEnvValidator struct {
	rules map[string][]ValidationRule
	calls map[string]int
	mu    sync.RWMutex
}

// NewMockEnvValidator creates a new mock environment validator
func NewMockEnvValidator() *MockEnvValidator {
	return &MockEnvValidator{
		rules: make(map[string][]ValidationRule),
		calls: make(map[string]int),
	}
}

// AddRule implements EnvValidator.AddRule
func (m *MockEnvValidator) AddRule(key string, rule ValidationRule) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["AddRule"]++
	
	if m.rules[key] == nil {
		m.rules[key] = make([]ValidationRule, 0)
	}
	m.rules[key] = append(m.rules[key], rule)
	return nil
}

// RemoveRule implements EnvValidator.RemoveRule
func (m *MockEnvValidator) RemoveRule(key string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["RemoveRule"]++
	delete(m.rules, key)
	return nil
}

// ValidateAll implements EnvValidator.ValidateAll
func (m *MockEnvValidator) ValidateAll() []ValidationError {
	m.calls["ValidateAll"]++
	return make([]ValidationError, 0)
}

// Validate implements EnvValidator.Validate
func (m *MockEnvValidator) Validate(key, value string) error {
	m.calls["Validate"]++
	return nil
}

// Required implements EnvValidator.Required
func (m *MockEnvValidator) Required(keys ...string) EnvValidator {
	m.calls["Required"]++
	return m
}

// NotEmpty implements EnvValidator.NotEmpty
func (m *MockEnvValidator) NotEmpty(keys ...string) EnvValidator {
	m.calls["NotEmpty"]++
	return m
}

// Pattern implements EnvValidator.Pattern
func (m *MockEnvValidator) Pattern(key, pattern string) EnvValidator {
	m.calls["Pattern"]++
	return m
}

// Range implements EnvValidator.Range
func (m *MockEnvValidator) Range(key string, min, max interface{}) EnvValidator {
	m.calls["Range"]++
	return m
}

// OneOf implements EnvValidator.OneOf
func (m *MockEnvValidator) OneOf(key string, values ...string) EnvValidator {
	m.calls["OneOf"]++
	return m
}

// GetCallCount returns the number of times a method was called
func (m *MockEnvValidator) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// Error implements the error interface for ValidationError
func (ve *ValidationError) Error() string {
	if ve.Message != "" {
		return ve.Message
	}
	return "validation error"
}