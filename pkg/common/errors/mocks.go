// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/common/errors/interfaces.go

// Package errors provides mocks for all error-related interfaces
package errors

import (
	"context"
	"sync"
	"time"
)

// MockMageError is a mock implementation of MageError
type MockMageError struct {
	mu         sync.RWMutex
	message    string
	code       ErrorCode
	severity   Severity
	context    ErrorContext
	cause      error
	stackTrace string
	calls      map[string]int
}

// NewMockMageError creates a new mock MageError
func NewMockMageError(message string) *MockMageError {
	return &MockMageError{
		message:  message,
		code:     ErrUnknown,
		severity: SeverityError,
		context: ErrorContext{
			Timestamp: time.Now(),
			Fields:    make(map[string]interface{}),
		},
		calls: make(map[string]int),
	}
}

func (m *MockMageError) Error() string {
	m.mu.Lock()
	m.calls["Error"]++
	m.mu.Unlock()
	return m.message
}

func (m *MockMageError) Code() ErrorCode {
	m.mu.Lock()
	m.calls["Code"]++
	m.mu.Unlock()
	return m.code
}

func (m *MockMageError) Severity() Severity {
	m.mu.Lock()
	m.calls["Severity"]++
	m.mu.Unlock()
	return m.severity
}

func (m *MockMageError) Context() ErrorContext {
	m.mu.Lock()
	m.calls["Context"]++
	m.mu.Unlock()
	return m.context
}

func (m *MockMageError) Cause() error {
	m.mu.Lock()
	m.calls["Cause"]++
	m.mu.Unlock()
	return m.cause
}

func (m *MockMageError) Unwrap() error {
	return m.Cause()
}

func (m *MockMageError) WithCode(code ErrorCode) MageError {
	m.mu.Lock()
	m.calls["WithCode"]++
	m.mu.Unlock()
	
	newErr := &MockMageError{
		message:  m.message,
		code:     code,
		severity: m.severity,
		context:  m.context,
		cause:    m.cause,
		calls:    make(map[string]int),
	}
	return newErr
}

func (m *MockMageError) WithSeverity(severity Severity) MageError {
	m.mu.Lock()
	m.calls["WithSeverity"]++
	m.mu.Unlock()
	
	newErr := &MockMageError{
		message:  m.message,
		code:     m.code,
		severity: severity,
		context:  m.context,
		cause:    m.cause,
		calls:    make(map[string]int),
	}
	return newErr
}

func (m *MockMageError) WithContext(ctx ErrorContext) MageError {
	m.mu.Lock()
	m.calls["WithContext"]++
	m.mu.Unlock()
	
	newErr := &MockMageError{
		message:  m.message,
		code:     m.code,
		severity: m.severity,
		context:  ctx,
		cause:    m.cause,
		calls:    make(map[string]int),
	}
	return newErr
}

func (m *MockMageError) WithField(key string, value interface{}) MageError {
	m.mu.Lock()
	m.calls["WithField"]++
	newContext := m.context
	if newContext.Fields == nil {
		newContext.Fields = make(map[string]interface{})
	}
	newContext.Fields[key] = value
	m.mu.Unlock()
	
	return m.WithContext(newContext)
}

func (m *MockMageError) WithFields(fields map[string]interface{}) MageError {
	m.mu.Lock()
	m.calls["WithFields"]++
	newContext := m.context
	if newContext.Fields == nil {
		newContext.Fields = make(map[string]interface{})
	}
	for k, v := range fields {
		newContext.Fields[k] = v
	}
	m.mu.Unlock()
	
	return m.WithContext(newContext)
}

func (m *MockMageError) WithCause(cause error) MageError {
	m.mu.Lock()
	m.calls["WithCause"]++
	m.mu.Unlock()
	
	newErr := &MockMageError{
		message:  m.message,
		code:     m.code,
		severity: m.severity,
		context:  m.context,
		cause:    cause,
		calls:    make(map[string]int),
	}
	return newErr
}

func (m *MockMageError) WithOperation(operation string) MageError {
	m.mu.Lock()
	m.calls["WithOperation"]++
	newContext := m.context
	newContext.Operation = operation
	m.mu.Unlock()
	
	return m.WithContext(newContext)
}

func (m *MockMageError) WithResource(resource string) MageError {
	m.mu.Lock()
	m.calls["WithResource"]++
	newContext := m.context
	newContext.Resource = resource
	m.mu.Unlock()
	
	return m.WithContext(newContext)
}

func (m *MockMageError) Format(includeStack bool) string {
	m.mu.Lock()
	m.calls["Format"]++
	m.mu.Unlock()
	
	return m.message
}

func (m *MockMageError) Is(target error) bool {
	m.mu.Lock()
	m.calls["Is"]++
	m.mu.Unlock()
	
	return false
}

func (m *MockMageError) As(target interface{}) bool {
	m.mu.Lock()
	m.calls["As"]++
	m.mu.Unlock()
	
	return false
}

func (m *MockMageError) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockErrorBuilder is a mock implementation of ErrorBuilder
type MockErrorBuilder struct {
	mu     sync.Mutex
	err    *MockMageError
	calls  map[string]int
}

// NewMockErrorBuilder creates a new mock error builder
func NewMockErrorBuilder() *MockErrorBuilder {
	return &MockErrorBuilder{
		err: &MockMageError{
			code:     ErrUnknown,
			severity: SeverityError,
			context: ErrorContext{
				Fields: make(map[string]interface{}),
			},
			calls: make(map[string]int),
		},
		calls: make(map[string]int),
	}
}

func (b *MockErrorBuilder) WithMessage(format string, args ...interface{}) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithMessage"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithCode(code ErrorCode) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithCode"]++
	b.err.code = code
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithSeverity(severity Severity) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithSeverity"]++
	b.err.severity = severity
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithContext(ctx ErrorContext) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithContext"]++
	b.err.context = ctx
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithField(key string, value interface{}) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithField"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithFields(fields map[string]interface{}) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithFields"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithCause(cause error) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithCause"]++
	b.err.cause = cause
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithOperation(operation string) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithOperation"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithResource(resource string) ErrorBuilder {
	b.mu.Lock()
	b.calls["WithResource"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) WithStackTrace() ErrorBuilder {
	b.mu.Lock()
	b.calls["WithStackTrace"]++
	b.mu.Unlock()
	return b
}

func (b *MockErrorBuilder) Build() MageError {
	b.mu.Lock()
	b.calls["Build"]++
	b.mu.Unlock()
	return b.err
}

func (b *MockErrorBuilder) GetCallCount(method string) int {
	b.mu.Lock()
	defer b.mu.Unlock()
	return b.calls[method]
}

// MockErrorHandler is a mock implementation of ErrorHandler
type MockErrorHandler struct {
	mu               sync.Mutex
	calls            map[string]int
	handleFunc       func(error) error
	handleContextFunc func(context.Context, error) error
}

// NewMockErrorHandler creates a new mock error handler
func NewMockErrorHandler() *MockErrorHandler {
	return &MockErrorHandler{
		calls: make(map[string]int),
	}
}

func (h *MockErrorHandler) Handle(err error) error {
	h.mu.Lock()
	h.calls["Handle"]++
	handleFunc := h.handleFunc
	h.mu.Unlock()
	
	if handleFunc != nil {
		return handleFunc(err)
	}
	return err
}

func (h *MockErrorHandler) HandleWithContext(ctx context.Context, err error) error {
	h.mu.Lock()
	h.calls["HandleWithContext"]++
	handleFunc := h.handleContextFunc
	h.mu.Unlock()
	
	if handleFunc != nil {
		return handleFunc(ctx, err)
	}
	return err
}

func (h *MockErrorHandler) OnError(code ErrorCode, handler func(MageError) error) ErrorHandler {
	h.mu.Lock()
	h.calls["OnError"]++
	h.mu.Unlock()
	return h
}

func (h *MockErrorHandler) OnSeverity(severity Severity, handler func(MageError) error) ErrorHandler {
	h.mu.Lock()
	h.calls["OnSeverity"]++
	h.mu.Unlock()
	return h
}

func (h *MockErrorHandler) SetDefault(handler func(error) error) ErrorHandler {
	h.mu.Lock()
	h.calls["SetDefault"]++
	h.handleFunc = handler
	h.mu.Unlock()
	return h
}

func (h *MockErrorHandler) SetFallback(handler func(error) error) ErrorHandler {
	h.mu.Lock()
	h.calls["SetFallback"]++
	h.mu.Unlock()
	return h
}

func (h *MockErrorHandler) GetCallCount(method string) int {
	h.mu.Lock()
	defer h.mu.Unlock()
	return h.calls[method]
}

// MockErrorChain is a mock implementation of ErrorChain
type MockErrorChain struct {
	mu     sync.Mutex
	errors []error
	calls  map[string]int
}

// NewMockErrorChain creates a new mock error chain
func NewMockErrorChain() *MockErrorChain {
	return &MockErrorChain{
		errors: make([]error, 0),
		calls:  make(map[string]int),
	}
}

func (c *MockErrorChain) Add(err error) ErrorChain {
	c.mu.Lock()
	c.calls["Add"]++
	c.errors = append(c.errors, err)
	c.mu.Unlock()
	return c
}

func (c *MockErrorChain) AddWithContext(err error, ctx ErrorContext) ErrorChain {
	c.mu.Lock()
	c.calls["AddWithContext"]++
	c.errors = append(c.errors, err)
	c.mu.Unlock()
	return c
}

func (c *MockErrorChain) Error() string {
	c.mu.Lock()
	c.calls["Error"]++
	c.mu.Unlock()
	
	if len(c.errors) == 0 {
		return "no errors"
	}
	return c.errors[0].Error()
}

func (c *MockErrorChain) Errors() []error {
	c.mu.Lock()
	c.calls["Errors"]++
	result := make([]error, len(c.errors))
	copy(result, c.errors)
	c.mu.Unlock()
	return result
}

func (c *MockErrorChain) First() error {
	c.mu.Lock()
	c.calls["First"]++
	c.mu.Unlock()
	
	if len(c.errors) == 0 {
		return nil
	}
	return c.errors[0]
}

func (c *MockErrorChain) Last() error {
	c.mu.Lock()
	c.calls["Last"]++
	c.mu.Unlock()
	
	if len(c.errors) == 0 {
		return nil
	}
	return c.errors[len(c.errors)-1]
}

func (c *MockErrorChain) Count() int {
	c.mu.Lock()
	c.calls["Count"]++
	count := len(c.errors)
	c.mu.Unlock()
	return count
}

func (c *MockErrorChain) HasError(code ErrorCode) bool {
	c.mu.Lock()
	c.calls["HasError"]++
	c.mu.Unlock()
	return false
}

func (c *MockErrorChain) FindByCode(code ErrorCode) MageError {
	c.mu.Lock()
	c.calls["FindByCode"]++
	c.mu.Unlock()
	return nil
}

func (c *MockErrorChain) ForEach(fn func(error) error) error {
	c.mu.Lock()
	c.calls["ForEach"]++
	c.mu.Unlock()
	return nil
}

func (c *MockErrorChain) Filter(predicate func(error) bool) []error {
	c.mu.Lock()
	c.calls["Filter"]++
	c.mu.Unlock()
	return nil
}

func (c *MockErrorChain) ToSlice() []error {
	return c.Errors()
}

func (c *MockErrorChain) GetCallCount(method string) int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.calls[method]
}