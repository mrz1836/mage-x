// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/common/paths/interfaces.go

// Package paths provides mocks for all path-related interfaces
package paths

import (
	"io/fs"
	"sync"
	"time"
)

// MockPathBuilder is a mock implementation of PathBuilder interface
type MockPathBuilder struct {
	mu       sync.RWMutex
	path     string
	calls    map[string]int
	options  PathOptions
	mockData map[string]interface{}
}

// NewMockPathBuilder creates a new mock path builder
func NewMockPathBuilder(path string) *MockPathBuilder {
	return &MockPathBuilder{
		path:     path,
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
		options:  GetDefaultOptions(),
	}
}

// SetMockData sets mock data for specific operations
func (m *MockPathBuilder) SetMockData(key string, value interface{}) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.mockData[key] = value
}

// GetMockData gets mock data for specific operations
func (m *MockPathBuilder) GetMockData(key string) (interface{}, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	value, exists := m.mockData[key]
	return value, exists
}

// Basic operations

func (m *MockPathBuilder) Join(elements ...string) PathBuilder {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Join"]++
	
	newPath := m.path
	for _, elem := range elements {
		newPath += "/" + elem
	}
	
	return &MockPathBuilder{
		path:     newPath,
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
		options:  m.options,
	}
}

func (m *MockPathBuilder) Dir() PathBuilder {
	m.calls["Dir"]++
	// Simple mock implementation
	return NewMockPathBuilder("/mock/dir")
}

func (m *MockPathBuilder) Base() string {
	m.calls["Base"]++
	if value, exists := m.GetMockData("base"); exists {
		return value.(string)
	}
	return "mock_base"
}

func (m *MockPathBuilder) Ext() string {
	m.calls["Ext"]++
	if value, exists := m.GetMockData("ext"); exists {
		return value.(string)
	}
	return ".mock"
}

func (m *MockPathBuilder) Clean() PathBuilder {
	m.calls["Clean"]++
	return m.Clone()
}

func (m *MockPathBuilder) Abs() (PathBuilder, error) {
	m.calls["Abs"]++
	if value, exists := m.GetMockData("abs_error"); exists {
		return nil, value.(error)
	}
	return NewMockPathBuilder("/mock/absolute/path"), nil
}

// Path operations

func (m *MockPathBuilder) Append(suffix string) PathBuilder {
	m.calls["Append"]++
	return NewMockPathBuilder(m.path + suffix)
}

func (m *MockPathBuilder) Prepend(prefix string) PathBuilder {
	m.calls["Prepend"]++
	return NewMockPathBuilder(prefix + m.path)
}

func (m *MockPathBuilder) WithExt(ext string) PathBuilder {
	m.calls["WithExt"]++
	return NewMockPathBuilder(m.path + ext)
}

func (m *MockPathBuilder) WithoutExt() PathBuilder {
	m.calls["WithoutExt"]++
	return NewMockPathBuilder(m.path + "_no_ext")
}

func (m *MockPathBuilder) WithName(name string) PathBuilder {
	m.calls["WithName"]++
	return NewMockPathBuilder("/mock/dir/" + name)
}

// Relative operations

func (m *MockPathBuilder) Rel(basepath string) (PathBuilder, error) {
	m.calls["Rel"]++
	if value, exists := m.GetMockData("rel_error"); exists {
		return nil, value.(error)
	}
	return NewMockPathBuilder("relative/path"), nil
}

func (m *MockPathBuilder) RelTo(target PathBuilder) (PathBuilder, error) {
	m.calls["RelTo"]++
	return m.Rel(target.String())
}

// Information

func (m *MockPathBuilder) String() string {
	return m.path
}

func (m *MockPathBuilder) IsAbs() bool {
	m.calls["IsAbs"]++
	if value, exists := m.GetMockData("is_abs"); exists {
		return value.(bool)
	}
	return m.path[0] == '/'
}

func (m *MockPathBuilder) IsDir() bool {
	m.calls["IsDir"]++
	if value, exists := m.GetMockData("is_dir"); exists {
		return value.(bool)
	}
	return false
}

func (m *MockPathBuilder) IsFile() bool {
	m.calls["IsFile"]++
	if value, exists := m.GetMockData("is_file"); exists {
		return value.(bool)
	}
	return true
}

func (m *MockPathBuilder) Exists() bool {
	m.calls["Exists"]++
	if value, exists := m.GetMockData("exists"); exists {
		return value.(bool)
	}
	return false
}

func (m *MockPathBuilder) Size() int64 {
	m.calls["Size"]++
	if value, exists := m.GetMockData("size"); exists {
		return value.(int64)
	}
	return 1024
}

func (m *MockPathBuilder) ModTime() time.Time {
	m.calls["ModTime"]++
	if value, exists := m.GetMockData("mod_time"); exists {
		return value.(time.Time)
	}
	return time.Now()
}

func (m *MockPathBuilder) Mode() fs.FileMode {
	m.calls["Mode"]++
	if value, exists := m.GetMockData("mode"); exists {
		return value.(fs.FileMode)
	}
	return 0644
}

// Directory operations

func (m *MockPathBuilder) Walk(fn WalkFunc) error {
	m.calls["Walk"]++
	if value, exists := m.GetMockData("walk_error"); exists {
		return value.(error)
	}
	// Simple mock walk
	return fn(m, nil, nil)
}

func (m *MockPathBuilder) List() ([]PathBuilder, error) {
	m.calls["List"]++
	if value, exists := m.GetMockData("list_error"); exists {
		return nil, value.(error)
	}
	return []PathBuilder{
		NewMockPathBuilder("mock1"),
		NewMockPathBuilder("mock2"),
	}, nil
}

func (m *MockPathBuilder) ListFiles() ([]PathBuilder, error) {
	m.calls["ListFiles"]++
	return m.List()
}

func (m *MockPathBuilder) ListDirs() ([]PathBuilder, error) {
	m.calls["ListDirs"]++
	return m.List()
}

func (m *MockPathBuilder) Glob(pattern string) ([]PathBuilder, error) {
	m.calls["Glob"]++
	if value, exists := m.GetMockData("glob_error"); exists {
		return nil, value.(error)
	}
	return []PathBuilder{NewMockPathBuilder("glob_match")}, nil
}

// Validation

func (m *MockPathBuilder) Validate() error {
	m.calls["Validate"]++
	if value, exists := m.GetMockData("validate_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) IsValid() bool {
	m.calls["IsValid"]++
	return m.Validate() == nil
}

func (m *MockPathBuilder) IsEmpty() bool {
	m.calls["IsEmpty"]++
	return m.path == ""
}

func (m *MockPathBuilder) IsSafe() bool {
	m.calls["IsSafe"]++
	if value, exists := m.GetMockData("is_safe"); exists {
		return value.(bool)
	}
	return true
}

// Modification

func (m *MockPathBuilder) Create() error {
	m.calls["Create"]++
	if value, exists := m.GetMockData("create_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) CreateDir() error {
	m.calls["CreateDir"]++
	if value, exists := m.GetMockData("create_dir_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) CreateDirAll() error {
	m.calls["CreateDirAll"]++
	if value, exists := m.GetMockData("create_dir_all_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) Remove() error {
	m.calls["Remove"]++
	if value, exists := m.GetMockData("remove_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) RemoveAll() error {
	m.calls["RemoveAll"]++
	if value, exists := m.GetMockData("remove_all_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) Copy(dest PathBuilder) error {
	m.calls["Copy"]++
	if value, exists := m.GetMockData("copy_error"); exists {
		return value.(error)
	}
	return nil
}

func (m *MockPathBuilder) Move(dest PathBuilder) error {
	m.calls["Move"]++
	if value, exists := m.GetMockData("move_error"); exists {
		return value.(error)
	}
	return nil
}

// Links

func (m *MockPathBuilder) Readlink() (PathBuilder, error) {
	m.calls["Readlink"]++
	if value, exists := m.GetMockData("readlink_error"); exists {
		return nil, value.(error)
	}
	return NewMockPathBuilder("link_target"), nil
}

func (m *MockPathBuilder) Symlink(target PathBuilder) error {
	m.calls["Symlink"]++
	if value, exists := m.GetMockData("symlink_error"); exists {
		return value.(error)
	}
	return nil
}

// Matching

func (m *MockPathBuilder) Match(pattern string) bool {
	m.calls["Match"]++
	if value, exists := m.GetMockData("match_result"); exists {
		return value.(bool)
	}
	return false
}

func (m *MockPathBuilder) Contains(sub string) bool {
	m.calls["Contains"]++
	return len(sub) > 0 // Simple mock logic
}

func (m *MockPathBuilder) HasPrefix(prefix string) bool {
	m.calls["HasPrefix"]++
	return len(prefix) > 0 // Simple mock logic
}

func (m *MockPathBuilder) HasSuffix(suffix string) bool {
	m.calls["HasSuffix"]++
	return len(suffix) > 0 // Simple mock logic
}

// Cloning

func (m *MockPathBuilder) Clone() PathBuilder {
	m.calls["Clone"]++
	return &MockPathBuilder{
		path:     m.path,
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
		options:  m.options,
	}
}

// GetCallCount returns the number of times a method was called
func (m *MockPathBuilder) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockPathMatcher is a mock implementation of PathMatcher interface
type MockPathMatcher struct {
	mu       sync.RWMutex
	patterns []string
	calls    map[string]int
	mockData map[string]interface{}
}

// NewMockPathMatcher creates a new mock path matcher
func NewMockPathMatcher() *MockPathMatcher {
	return &MockPathMatcher{
		patterns: make([]string, 0),
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
	}
}

func (m *MockPathMatcher) Match(path string) bool {
	m.calls["Match"]++
	if value, exists := m.mockData["match_result"]; exists {
		return value.(bool)
	}
	return false
}

func (m *MockPathMatcher) MatchPath(path PathBuilder) bool {
	m.calls["MatchPath"]++
	return m.Match(path.String())
}

func (m *MockPathMatcher) Compile(pattern string) error {
	m.calls["Compile"]++
	m.patterns = []string{pattern}
	return nil
}

func (m *MockPathMatcher) Pattern() string {
	m.calls["Pattern"]++
	if len(m.patterns) > 0 {
		return m.patterns[0]
	}
	return ""
}

func (m *MockPathMatcher) AddPattern(pattern string) error {
	m.calls["AddPattern"]++
	m.patterns = append(m.patterns, pattern)
	return nil
}

func (m *MockPathMatcher) RemovePattern(pattern string) error {
	m.calls["RemovePattern"]++
	for i, p := range m.patterns {
		if p == pattern {
			m.patterns = append(m.patterns[:i], m.patterns[i+1:]...)
			return nil
		}
	}
	return nil
}

func (m *MockPathMatcher) ClearPatterns() error {
	m.calls["ClearPatterns"]++
	m.patterns = make([]string, 0)
	return nil
}

func (m *MockPathMatcher) Patterns() []string {
	m.calls["Patterns"]++
	result := make([]string, len(m.patterns))
	copy(result, m.patterns)
	return result
}

func (m *MockPathMatcher) SetCaseSensitive(sensitive bool) PathMatcher {
	m.calls["SetCaseSensitive"]++
	return m
}

func (m *MockPathMatcher) SetRecursive(recursive bool) PathMatcher {
	m.calls["SetRecursive"]++
	return m
}

func (m *MockPathMatcher) SetMaxDepth(depth int) PathMatcher {
	m.calls["SetMaxDepth"]++
	return m
}

func (m *MockPathMatcher) MatchAny(paths ...string) bool {
	m.calls["MatchAny"]++
	return false
}

func (m *MockPathMatcher) MatchAll(paths ...string) bool {
	m.calls["MatchAll"]++
	return false
}

func (m *MockPathMatcher) Filter(paths []string) []string {
	m.calls["Filter"]++
	return make([]string, 0)
}

func (m *MockPathMatcher) FilterPaths(paths []PathBuilder) []PathBuilder {
	m.calls["FilterPaths"]++
	return make([]PathBuilder, 0)
}

func (m *MockPathMatcher) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockPathValidator is a mock implementation of PathValidator interface
type MockPathValidator struct {
	mu       sync.RWMutex
	rules    []ValidationRule
	calls    map[string]int
	mockData map[string]interface{}
}

// NewMockPathValidator creates a new mock path validator
func NewMockPathValidator() *MockPathValidator {
	return &MockPathValidator{
		rules:    make([]ValidationRule, 0),
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
	}
}

func (m *MockPathValidator) AddRule(rule ValidationRule) error {
	m.calls["AddRule"]++
	m.rules = append(m.rules, rule)
	return nil
}

func (m *MockPathValidator) RemoveRule(name string) error {
	m.calls["RemoveRule"]++
	return nil
}

func (m *MockPathValidator) ClearRules() error {
	m.calls["ClearRules"]++
	m.rules = make([]ValidationRule, 0)
	return nil
}

func (m *MockPathValidator) Rules() []ValidationRule {
	m.calls["Rules"]++
	result := make([]ValidationRule, len(m.rules))
	copy(result, m.rules)
	return result
}

func (m *MockPathValidator) Validate(path string) []ValidationError {
	m.calls["Validate"]++
	if value, exists := m.mockData["validation_errors"]; exists {
		return value.([]ValidationError)
	}
	return make([]ValidationError, 0)
}

func (m *MockPathValidator) ValidatePath(path PathBuilder) []ValidationError {
	m.calls["ValidatePath"]++
	return m.Validate(path.String())
}

func (m *MockPathValidator) IsValid(path string) bool {
	m.calls["IsValid"]++
	return len(m.Validate(path)) == 0
}

func (m *MockPathValidator) IsValidPath(path PathBuilder) bool {
	m.calls["IsValidPath"]++
	return m.IsValid(path.String())
}

func (m *MockPathValidator) RequireAbsolute() PathValidator {
	m.calls["RequireAbsolute"]++
	return m
}

func (m *MockPathValidator) RequireRelative() PathValidator {
	m.calls["RequireRelative"]++
	return m
}

func (m *MockPathValidator) RequireExists() PathValidator {
	m.calls["RequireExists"]++
	return m
}

func (m *MockPathValidator) RequireNotExists() PathValidator {
	m.calls["RequireNotExists"]++
	return m
}

func (m *MockPathValidator) RequireReadable() PathValidator {
	m.calls["RequireReadable"]++
	return m
}

func (m *MockPathValidator) RequireWritable() PathValidator {
	m.calls["RequireWritable"]++
	return m
}

func (m *MockPathValidator) RequireExecutable() PathValidator {
	m.calls["RequireExecutable"]++
	return m
}

func (m *MockPathValidator) RequireDirectory() PathValidator {
	m.calls["RequireDirectory"]++
	return m
}

func (m *MockPathValidator) RequireFile() PathValidator {
	m.calls["RequireFile"]++
	return m
}

func (m *MockPathValidator) RequireExtension(exts ...string) PathValidator {
	m.calls["RequireExtension"]++
	return m
}

func (m *MockPathValidator) RequireMaxLength(length int) PathValidator {
	m.calls["RequireMaxLength"]++
	return m
}

func (m *MockPathValidator) RequirePattern(pattern string) PathValidator {
	m.calls["RequirePattern"]++
	return m
}

func (m *MockPathValidator) ForbidPattern(pattern string) PathValidator {
	m.calls["ForbidPattern"]++
	return m
}

func (m *MockPathValidator) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}

// MockPathSet is a mock implementation of PathSet interface
type MockPathSet struct {
	mu       sync.RWMutex
	paths    map[string]bool
	calls    map[string]int
	mockData map[string]interface{}
}

// NewMockPathSet creates a new mock path set
func NewMockPathSet() *MockPathSet {
	return &MockPathSet{
		paths:    make(map[string]bool),
		calls:    make(map[string]int),
		mockData: make(map[string]interface{}),
	}
}

func (m *MockPathSet) Add(path string) bool {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Add"]++
	
	if m.paths[path] {
		return false
	}
	m.paths[path] = true
	return true
}

func (m *MockPathSet) AddPath(path PathBuilder) bool {
	m.calls["AddPath"]++
	return m.Add(path.String())
}

func (m *MockPathSet) Remove(path string) bool {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Remove"]++
	
	if !m.paths[path] {
		return false
	}
	delete(m.paths, path)
	return true
}

func (m *MockPathSet) RemovePath(path PathBuilder) bool {
	m.calls["RemovePath"]++
	return m.Remove(path.String())
}

func (m *MockPathSet) Contains(path string) bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Contains"]++
	return m.paths[path]
}

func (m *MockPathSet) ContainsPath(path PathBuilder) bool {
	m.calls["ContainsPath"]++
	return m.Contains(path.String())
}

func (m *MockPathSet) Clear() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.calls["Clear"]++
	m.paths = make(map[string]bool)
	return nil
}

func (m *MockPathSet) Size() int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Size"]++
	return len(m.paths)
}

func (m *MockPathSet) IsEmpty() bool {
	m.calls["IsEmpty"]++
	return m.Size() == 0
}

func (m *MockPathSet) Paths() []string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	m.calls["Paths"]++
	
	result := make([]string, 0, len(m.paths))
	for path := range m.paths {
		result = append(result, path)
	}
	return result
}

func (m *MockPathSet) PathBuilders() []PathBuilder {
	m.calls["PathBuilders"]++
	paths := m.Paths()
	result := make([]PathBuilder, len(paths))
	for i, path := range paths {
		result[i] = NewMockPathBuilder(path)
	}
	return result
}

func (m *MockPathSet) Union(other PathSet) PathSet {
	m.calls["Union"]++
	return NewMockPathSet()
}

func (m *MockPathSet) Intersection(other PathSet) PathSet {
	m.calls["Intersection"]++
	return NewMockPathSet()
}

func (m *MockPathSet) Difference(other PathSet) PathSet {
	m.calls["Difference"]++
	return NewMockPathSet()
}

func (m *MockPathSet) SymmetricDifference(other PathSet) PathSet {
	m.calls["SymmetricDifference"]++
	return NewMockPathSet()
}

func (m *MockPathSet) Filter(predicate func(string) bool) PathSet {
	m.calls["Filter"]++
	return NewMockPathSet()
}

func (m *MockPathSet) FilterPaths(predicate func(PathBuilder) bool) PathSet {
	m.calls["FilterPaths"]++
	return NewMockPathSet()
}

func (m *MockPathSet) ForEach(fn func(string) error) error {
	m.calls["ForEach"]++
	return nil
}

func (m *MockPathSet) ForEachPath(fn func(PathBuilder) error) error {
	m.calls["ForEachPath"]++
	return nil
}

func (m *MockPathSet) GetCallCount(method string) int {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.calls[method]
}