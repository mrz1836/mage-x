package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestConfigLoad(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		configFile  string
		configData  string
		expectErr   bool
		expectValid bool
	}{
		{
			name:       "valid config file",
			configFile: ".mage.yaml",
			configData: `
project:
  name: testproject
  version: v1.0.0
  description: A test project

build:
  output: bin
  trimpath: true
  platforms:
    - linux/amd64
    - darwin/amd64

tools:
  golangci_lint: v1.55.2
  fumpt: latest
`,
			expectErr:   false,
			expectValid: true,
		},
		{
			name:       "invalid YAML syntax",
			configFile: ".mage.yaml",
			configData: `
project:
  name: testproject
  version: v1.0.0
build:
  output: bin
    invalid_indent: true
`,
			expectErr:   true,
			expectValid: false,
		},
		{
			name:        "missing config file",
			configFile:  "",
			configData:  "",
			expectErr:   false,
			expectValid: true, // Should load defaults
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.configData != "" {
				env.CreateFile(tt.configFile, tt.configData)
			}

			config := Config{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return config.Load()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				if tt.expectValid {
					assert.NotEmpty(t, config.Project.Name)
				}
			}
		})
	}
}

func TestConfigValidate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	tests := []struct {
		name      string
		config    Config
		expectErr bool
	}{
		{
			name: "valid config",
			config: Config{
				Project: ProjectConfig{
					Name:        "testproject",
					Version:     "v1.0.0",
					Description: "A test project",
				},
				Build: BuildConfig{
					Output:   "bin",
					TrimPath: true,
					Platforms: []string{"linux/amd64", "darwin/amd64"},
				},
			},
			expectErr: false,
		},
		{
			name: "missing project name",
			config: Config{
				Project: ProjectConfig{
					Version:     "v1.0.0",
					Description: "A test project",
				},
			},
			expectErr: true,
		},
		{
			name: "invalid version format",
			config: Config{
				Project: ProjectConfig{
					Name:    "testproject",
					Version: "invalid-version",
				},
			},
			expectErr: true,
		},
		{
			name: "invalid platform format",
			config: Config{
				Project: ProjectConfig{
					Name:    "testproject",
					Version: "v1.0.0",
				},
				Build: BuildConfig{
					Platforms: []string{"invalid-platform"},
				},
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.config.Validate()

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestConfigSave(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		config    Config
		filename  string
		expectErr bool
	}{
		{
			name: "save valid config",
			config: Config{
				Project: ProjectConfig{
					Name:        "testproject",
					Version:     "v1.0.0",
					Description: "A test project",
				},
				Build: BuildConfig{
					Output:   "bin",
					TrimPath: true,
				},
			},
			filename:  ".mage.yaml",
			expectErr: false,
		},
		{
			name: "save to custom file",
			config: Config{
				Project: ProjectConfig{
					Name:    "myproject",
					Version: "v2.0.0",
				},
			},
			filename:  "custom-config.yaml",
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return tt.config.Save(tt.filename)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
