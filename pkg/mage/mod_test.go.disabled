package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestModInit(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()

	tests := []struct {
		name       string
		moduleName string
		setupMock  func()
		expectErr  bool
	}{
		{
			name:       "successful mod init",
			moduleName: "github.com/test/project",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name:       "mod init with existing module",
			moduleName: "example.com/myapp",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Init()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModTidy(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod tidy",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod tidy failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Tidy()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModDownload(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod download",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod download failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Download()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModVerify(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod verify",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod verify failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Verify()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModGraph(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod graph",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod graph failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Graph()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModWhy(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		pkg       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod why",
			pkg:  "github.com/stretchr/testify",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod why for unknown package",
			pkg:  "github.com/unknown/package",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod why failure",
			pkg:  "github.com/example/dep",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Why()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModEdit(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		args      []string
		setupMock func()
		expectErr bool
	}{
		{
			name: "edit go version",
			args: []string{"-go=1.21"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "add require",
			args: []string{"-require=github.com/example/dep@v1.0.0"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod edit failure",
			args: []string{"-invalid"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Edit(tt.args...)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModVendor(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod vendor",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "mod vendor failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Vendor()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModGet(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		packages  []string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "get specific package",
			packages: []string{"github.com/stretchr/testify@v1.8.4"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("get", nil)
			},
			expectErr: false,
		},
		{
			name:     "get multiple packages",
			packages: []string{"github.com/stretchr/testify", "github.com/pkg/errors"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("get", nil)
			},
			expectErr: false,
		},
		{
			name:     "get latest version",
			packages: []string{"github.com/example/dep@latest"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("get", nil)
			},
			expectErr: false,
		},
		{
			name:     "get upgrade all",
			packages: []string{"-u", "./..."},
			setupMock: func() {
				env.Builder.ExpectGoCommand("get", nil)
			},
			expectErr: false,
		},
		{
			name:     "get failure",
			packages: []string{"github.com/invalid/package"},
			setupMock: func() {
				env.Builder.ExpectGoCommand("get", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Get(tt.packages...)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModClean(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mod clean",
			setupMock: func() {
				env.Builder.ExpectGoCommand("clean", nil)
			},
			expectErr: false,
		},
		{
			name: "mod clean failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("clean", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.Clean()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestModList(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		pattern   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "list all modules",
			pattern: "all",
			setupMock: func() {
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("github.com/test/project\ngithub.com/stretchr/testify", nil)
			},
			expectErr: false,
		},
		{
			name:    "list current module",
			pattern: "",
			setupMock: func() {
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("github.com/test/project", nil)
			},
			expectErr: false,
		},
		{
			name:    "list with pattern",
			pattern: "github.com/...",
			setupMock: func() {
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("github.com/test/project", nil)
			},
			expectErr: false,
		},
		{
			name:    "list failure",
			pattern: "invalid",
			setupMock: func() {
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			mod := Mod{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return mod.List(tt.pattern)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
