package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestRunDev(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful dev run",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil)
			},
			expectErr: false,
		},
		{
			name: "dev run failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Dev()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunProd(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create binary
	env.CreateFile("bin/app", "#!/bin/bash\necho 'Hello World'")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful prod run",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // ./bin/app
			},
			expectErr: false,
		},
		{
			name: "prod run failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // binary execution fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Prod()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunWatch(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful watch mode",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // file watcher
			},
			expectErr: false,
		},
		{
			name: "watch mode failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // watcher fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Watch()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunDebug(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful debug run",
			port: 2345,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // dlv debug
			},
			expectErr: false,
		},
		{
			name: "debug with custom port",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // dlv debug
			},
			expectErr: false,
		},
		{
			name: "debug run failure",
			port: 2345,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // dlv fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Debug(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunProfile(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		profileType string
		setupMock   func()
		expectErr   bool
	}{
		{
			name:        "CPU profiling",
			profileType: "cpu",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run with profiling flags
			},
			expectErr: false,
		},
		{
			name:        "memory profiling",
			profileType: "mem",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run with memory profiling
			},
			expectErr: false,
		},
		{
			name:        "block profiling",
			profileType: "block",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run with block profiling
			},
			expectErr: false,
		},
		{
			name:        "profiling failure",
			profileType: "cpu",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // profiling fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Profile(tt.profileType)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunBenchmark(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		pattern   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "run all benchmarks",
			pattern: ".",
			setupMock: func() {
				env.Builder.ExpectGoCommand("test", nil) // go test -bench
			},
			expectErr: false,
		},
		{
			name:    "run specific benchmark",
			pattern: "BenchmarkMyFunc",
			setupMock: func() {
				env.Builder.ExpectGoCommand("test", nil) // go test -bench
			},
			expectErr: false,
		},
		{
			name:    "benchmark failure",
			pattern: ".",
			setupMock: func() {
				env.Builder.ExpectGoCommand("test", assert.AnError) // benchmark fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Benchmark(tt.pattern)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunServer(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "start server on default port",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run main.go
			},
			expectErr: false,
		},
		{
			name: "start server on custom port",
			port: 3000,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run main.go
			},
			expectErr: false,
		},
		{
			name: "server start failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // server fails to start
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Server(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunMigrations(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		direction string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "run migrations up",
			direction: "up",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // migration tool
			},
			expectErr: false,
		},
		{
			name:      "run migrations down",
			direction: "down",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // migration tool
			},
			expectErr: false,
		},
		{
			name:      "migration failure",
			direction: "up",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // migration fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Migrations(tt.direction)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunSeeds(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		seedName  string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "run all seeds",
			seedName: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // seed runner
			},
			expectErr: false,
		},
		{
			name:     "run specific seed",
			seedName: "users",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // seed runner
			},
			expectErr: false,
		},
		{
			name:     "seed failure",
			seedName: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // seed fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Seeds(tt.seedName)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestRunWorker(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name       string
		workerName string
		setupMock  func()
		expectErr  bool
	}{
		{
			name:       "start default worker",
			workerName: "",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run worker/main.go
			},
			expectErr: false,
		},
		{
			name:       "start named worker",
			workerName: "email",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run worker/email/main.go
			},
			expectErr: false,
		},
		{
			name:       "worker start failure",
			workerName: "",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // worker fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			run := Run{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return run.Worker(tt.workerName)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
