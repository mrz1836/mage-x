package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestDepsDownload(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful download",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "download failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Download()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsTidy(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful tidy",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "tidy failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Tidy()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsUpdate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful update",
			setupMock: func() {
				// Mock listing dependencies
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("github.com/example/dep", nil)
				// Mock getting latest version
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("v1.0.0 v1.1.0", nil)
				// Mock update command
				env.Builder.ExpectGoCommand("get", nil)
				// Mock tidy
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "list dependencies failure",
			setupMock: func() {
				env.Runner.On("RunCmdOutput", "go",
					testutil.Cmd.HasSubcommand("list")).Return("", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Update()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsClean(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful clean",
			setupMock: func() {
				env.Builder.ExpectGoCommand("clean", nil)
			},
			expectErr: false,
		},
		{
			name: "clean failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("clean", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Clean()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsGraph(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful graph",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "graph failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Graph()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsWhy(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		dep       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful why",
			dep:  "github.com/example/dep",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "why failure",
			dep:  "github.com/example/dep",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Why(tt.dep)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDepsVerify(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful verify",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil)
			},
			expectErr: false,
		},
		{
			name: "verify failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			deps := Deps{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return deps.Verify()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
