package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestVersionShow(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "show version with git tag",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.2.3", nil)
				env.Builder.ExpectGitCommand("rev-parse", "abc123", nil)
			},
			expectErr: false,
		},
		{
			name: "show version without git",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "", assert.AnError)
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			version := Version{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return version.Show()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestVersionBump(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")
	env.CreateMageConfig(`
project:
  name: testproject
  version: v1.0.0
`)

	tests := []struct {
		name      string
		bumpType  string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "bump patch version",
			bumpType: "patch",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(nil) // for file operations
			},
			expectErr: false,
		},
		{
			name:     "bump minor version",
			bumpType: "minor",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:     "bump major version",
			bumpType: "major",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:     "invalid bump type",
			bumpType: "invalid",
			setupMock: func() {
				// No mocks needed for validation error
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			version := Version{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return version.Bump(tt.bumpType)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestVersionTag(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")
	env.CreateMageConfig(`
project:
  name: testproject
  version: v1.0.0
`)

	tests := []struct {
		name      string
		tag       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "create version tag",
			tag:  "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", nil)
			},
			expectErr: false,
		},
		{
			name: "create annotated tag",
			tag:  "v1.0.1",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", nil)
			},
			expectErr: false,
		},
		{
			name: "tag creation failure",
			tag:  "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			version := Version{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return version.Tag(tt.tag)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestVersionCheck(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		remote      string
		setupMock   func()
		expectErr   bool
		expectNewer bool
	}{
		{
			name:   "check github releases",
			remote: "github.com/test/project",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(nil) // for github API call
			},
			expectErr:   false,
			expectNewer: false,
		},
		{
			name:   "check with newer version available",
			remote: "github.com/test/project",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr:   false,
			expectNewer: true,
		},
		{
			name:   "check failure",
			remote: "invalid-remote",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil)
				env.Builder.ExpectAnyCommand(assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			version := Version{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return version.Check(tt.remote)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestVersionNext(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		currentVer  string
		bumpType    string
		expectedVer string
		expectErr   bool
	}{
		{
			name:        "next patch version",
			currentVer:  "v1.0.0",
			bumpType:    "patch",
			expectedVer: "v1.0.1",
			expectErr:   false,
		},
		{
			name:        "next minor version",
			currentVer:  "v1.0.5",
			bumpType:    "minor",
			expectedVer: "v1.1.0",
			expectErr:   false,
		},
		{
			name:        "next major version",
			currentVer:  "v1.2.3",
			bumpType:    "major",
			expectedVer: "v2.0.0",
			expectErr:   false,
		},
		{
			name:       "invalid current version",
			currentVer: "invalid",
			bumpType:   "patch",
			expectErr:  true,
		},
		{
			name:       "invalid bump type",
			currentVer: "v1.0.0",
			bumpType:   "invalid",
			expectErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			version := Version{}
			result, err := version.Next(tt.currentVer, tt.bumpType)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedVer, result)
			}
		})
	}
}

func TestVersionCompare(t *testing.T) {
	tests := []struct {
		name     string
		versionA string
		versionB string
		expected int
	}{
		{
			name:     "equal versions",
			versionA: "v1.0.0",
			versionB: "v1.0.0",
			expected: 0,
		},
		{
			name:     "A greater than B",
			versionA: "v1.1.0",
			versionB: "v1.0.0",
			expected: 1,
		},
		{
			name:     "A less than B",
			versionA: "v1.0.0",
			versionB: "v1.1.0",
			expected: -1,
		},
		{
			name:     "major version difference",
			versionA: "v2.0.0",
			versionB: "v1.9.9",
			expected: 1,
		},
		{
			name:     "patch version difference",
			versionA: "v1.0.1",
			versionB: "v1.0.2",
			expected: -1,
		},
		{
			name:     "versions without v prefix",
			versionA: "1.0.0",
			versionB: "1.0.1",
			expected: -1,
		},
		{
			name:     "dev version",
			versionA: "v1.0.0",
			versionB: "dev",
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			version := Version{}
			result := version.Compare(tt.versionA, tt.versionB)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestVersionValidate(t *testing.T) {
	tests := []struct {
		name      string
		version   string
		expectErr bool
	}{
		{
			name:      "valid semantic version",
			version:   "v1.0.0",
			expectErr: false,
		},
		{
			name:      "valid version without v prefix",
			version:   "1.0.0",
			expectErr: false,
		},
		{
			name:      "valid version with pre-release",
			version:   "v1.0.0-alpha.1",
			expectErr: false,
		},
		{
			name:      "valid version with build metadata",
			version:   "v1.0.0+build.1",
			expectErr: false,
		},
		{
			name:      "dev version",
			version:   "dev",
			expectErr: false,
		},
		{
			name:      "invalid version format",
			version:   "1.0",
			expectErr: true,
		},
		{
			name:      "invalid version with letters",
			version:   "v1.0.a",
			expectErr: true,
		},
		{
			name:      "empty version",
			version:   "",
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			version := Version{}
			err := version.Validate(tt.version)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestVersionParse(t *testing.T) {
	tests := []struct {
		name      string
		version   string
		expected  []int
		expectErr bool
	}{
		{
			name:      "parse v1.0.0",
			version:   "v1.0.0",
			expected:  []int{1, 0, 0},
			expectErr: false,
		},
		{
			name:      "parse 2.1.3",
			version:   "2.1.3",
			expected:  []int{2, 1, 3},
			expectErr: false,
		},
		{
			name:      "parse with pre-release",
			version:   "v1.0.0-alpha.1",
			expected:  []int{1, 0, 0},
			expectErr: false,
		},
		{
			name:      "parse invalid version",
			version:   "invalid",
			expected:  nil,
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			version := Version{}
			result, err := version.Parse(tt.version)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}
		})
	}
}

func TestVersionFormat(t *testing.T) {
	tests := []struct {
		name     string
		parts    []int
		expected string
	}{
		{
			name:     "format standard version",
			parts:    []int{1, 0, 0},
			expected: "v1.0.0",
		},
		{
			name:     "format version with minor/patch",
			parts:    []int{2, 1, 3},
			expected: "v2.1.3",
		},
		{
			name:     "format large version numbers",
			parts:    []int{10, 20, 30},
			expected: "v10.20.30",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			version := Version{}
			result := version.Format(tt.parts)
			assert.Equal(t, tt.expected, result)
		})
	}
}
