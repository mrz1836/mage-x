package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestFormatAll(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful format all",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil). // gofumpt
							ExpectAnyCommand(nil). // goimports
							ExpectAnyCommand(nil)  // other formatters
			},
			expectErr: false,
		},
		{
			name: "format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.All()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatGo(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create some Go files to format
	env.CreateFile("main.go", `package main

import "fmt"

func main(){
fmt.Println("hello")
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful go formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // gofumpt
			},
			expectErr: false,
		},
		{
			name: "go format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // gofumpt fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Go()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatImports(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create Go file with messy imports
	env.CreateFile("main.go", `package main

import "os"
import "fmt"
import "github.com/pkg/errors"

func main() {
	fmt.Println("hello")
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful import formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // goimports
			},
			expectErr: false,
		},
		{
			name: "import format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // goimports fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Imports()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatYAML(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create YAML file with formatting issues
	env.CreateFile("config.yaml", `
name:   "test"
version:    "1.0.0"
settings:
  debug: true
  port:   8080
`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful yaml formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // yaml formatter
			},
			expectErr: false,
		},
		{
			name: "yaml format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // yaml formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.YAML()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatJSON(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create JSON file with formatting issues
	env.CreateFile("config.json", `{"name":"test","version":"1.0.0","settings":{"debug":true,"port":8080}}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful json formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // json formatter
			},
			expectErr: false,
		},
		{
			name: "json format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // json formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.JSON()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatMarkdown(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create markdown file
	env.CreateFile("README.md", `# Project

This is a test project.

## Features

- Feature 1
- Feature 2

### Installation

Run the following command:

` + "```bash" + `
go install
` + "```" + `
`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful markdown formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // markdown formatter
			},
			expectErr: false,
		},
		{
			name: "markdown format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // markdown formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Markdown()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatSQL(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create SQL file
	env.CreateFile("schema.sql", `CREATE TABLE users (id INT PRIMARY KEY,name VARCHAR(255) NOT NULL,email VARCHAR(255) UNIQUE);

INSERT INTO users (id,name,email) VALUES (1,'John','john@example.com');`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful sql formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // sql formatter
			},
			expectErr: false,
		},
		{
			name: "sql format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // sql formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.SQL()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatDockerfile(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create Dockerfile
	env.CreateFile("Dockerfile", `FROM golang:1.21-alpine
WORKDIR /app
COPY . .
RUN go build -o app .
EXPOSE 8080
CMD ["./app"]`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful dockerfile formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // dockerfile formatter
			},
			expectErr: false,
		},
		{
			name: "dockerfile format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // dockerfile formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Dockerfile()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatShell(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create shell script
	env.CreateFile("script.sh", `#!/bin/bash
set -e
echo "Starting build..."
go build -o app .
echo "Build complete"`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful shell formatting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // shell formatter (shfmt)
			},
			expectErr: false,
		},
		{
			name: "shell format failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // shell formatter fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Shell()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestFormatCheck(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "all files properly formatted",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // format check passes
			},
			expectErr: false,
		},
		{
			name: "formatting issues found",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // format check fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			format := Format{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return format.Check()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
