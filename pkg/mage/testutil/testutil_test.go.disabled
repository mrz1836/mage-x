package testutil

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMockRunner(t *testing.T) {
	runner, builder := NewMockRunner()

	// Test basic command mocking
	builder.ExpectGoCommand("build", nil)
	
	err := runner.RunCmd("go", "build", "-o", "myapp")
	assert.NoError(t, err)

	// Verify expectations
	runner.AssertExpectations(t)
}

func TestMockBuilder(t *testing.T) {
	t.Run("ExpectVersion", func(t *testing.T) {
		runner, builder := NewMockRunner()
		
		builder.ExpectVersion("v1.2.3")
		
		output, err := runner.RunCmdOutput("git", "describe", "--tags", "--abbrev=0")
		assert.NoError(t, err)
		assert.Equal(t, "v1.2.3", output)
		
		runner.AssertExpectations(t)
	})

	t.Run("ExpectFailure", func(t *testing.T) {
		runner, builder := NewMockRunner()
		
		builder.ExpectFailure("build failed")
		
		err := runner.RunCmd("go", "build")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "build failed")
		
		runner.AssertExpectations(t)
	})

	t.Run("ExpectSuccess", func(t *testing.T) {
		runner, builder := NewMockRunner()
		
		builder.ExpectSuccess()
		
		err := runner.RunCmd("go", "test")
		assert.NoError(t, err)
		
		runner.AssertExpectations(t)
	})
}

func TestCommandMatcher(t *testing.T) {
	t.Run("ContainsArg", func(t *testing.T) {
		matcher := Cmd.ContainsArg("-o")
		
		assert.True(t, matcher([]string{"build", "-o", "myapp"}))
		assert.False(t, matcher([]string{"build", "myapp"}))
	})

	t.Run("HasSubcommand", func(t *testing.T) {
		matcher := Cmd.HasSubcommand("build")
		
		assert.True(t, matcher([]string{"build", "-o", "myapp"}))
		assert.False(t, matcher([]string{"test", "-v"}))
	})

	t.Run("ContainsFlag", func(t *testing.T) {
		matcher := Cmd.ContainsFlag("-v")
		
		assert.True(t, matcher([]string{"test", "-v"}))
		assert.True(t, matcher([]string{"test", "-verbose"}))
		assert.False(t, matcher([]string{"test", "pkg"}))
	})
}

func TestTestEnvironment(t *testing.T) {
	env := NewTestEnvironment(t)
	defer env.Cleanup()

	t.Run("CreateGoMod", func(t *testing.T) {
		env.CreateGoMod("github.com/test/project")
		
		assert.True(t, env.FileExists("go.mod"))
		content := env.ReadFile("go.mod")
		assert.Contains(t, content, "module github.com/test/project")
	})

	t.Run("CreateProjectStructure", func(t *testing.T) {
		env.CreateProjectStructure()
		
		assert.True(t, env.FileExists("cmd/app/main.go"))
		assert.True(t, env.FileExists("pkg/utils"))
		assert.True(t, env.FileExists("bin"))
		assert.True(t, env.FileExists("docs"))
	})

	t.Run("CreateMageConfig", func(t *testing.T) {
		config := `project:
  name: testproject
  binary: testapp

build:
  output: bin
`
		env.CreateMageConfig(config)
		
		assert.True(t, env.FileExists(".mage.yaml"))
		content := env.ReadFile(".mage.yaml")
		assert.Contains(t, content, "testproject")
	})

	t.Run("WithMockRunner", func(t *testing.T) {
		env.Builder.ExpectGoCommand("version", nil)
		
		// Mock runner functions for testing (normally provided by calling package)
		var currentRunner interface{} = env.Runner
		setter := func(r interface{}) { currentRunner = r }
		getter := func() interface{} { return currentRunner }
		
		err := env.WithMockRunner(setter, getter, func() error {
			// In real usage, this would call the actual command through the mage package
			return env.Runner.RunCmd("go", "version")
		})
		
		assert.NoError(t, err)
		env.Runner.AssertExpectations(t)
	})
}

func TestStandardMocks(t *testing.T) {
	env := NewTestEnvironment(t)
	defer env.Cleanup()

	t.Run("ForBuild", func(t *testing.T) {
		mocks := env.StandardMocks().ForBuild()
		require.NotNil(t, mocks)
		
		// Test that build-related commands work
		var currentRunner interface{} = env.Runner
		setter := func(r interface{}) { currentRunner = r }
		getter := func() interface{} { return currentRunner }
		
		err := env.WithMockRunner(setter, getter, func() error {
			if err := env.Runner.RunCmd("go", "build"); err != nil {
				return err
			}
			
			_, err := env.Runner.RunCmdOutput("git", "describe", "--tags")
			return err
		})
		
		assert.NoError(t, err)
	})

	t.Run("ForAll", func(t *testing.T) {
		mocks := env.StandardMocks().ForAll()
		require.NotNil(t, mocks)
		
		// Test that various commands work
		var currentRunner interface{} = env.Runner
		setter := func(r interface{}) { currentRunner = r }
		getter := func() interface{} { return currentRunner }
		
		err := env.WithMockRunner(setter, getter, func() error {
			commands := [][]string{
				{"go", "build"},
				{"go", "test"},
				{"git", "status"},
			}
			
			for _, cmd := range commands {
				if err := env.Runner.RunCmd(cmd[0], cmd[1:]...); err != nil {
					return fmt.Errorf("command %v failed: %w", cmd, err)
				}
			}
			
			return nil
		})
		
		assert.NoError(t, err)
	})
}