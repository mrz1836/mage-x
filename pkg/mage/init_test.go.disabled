package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestInitProject(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	tests := []struct {
		name        string
		projectName string
		projectType string
		setupMock   func()
		expectErr   bool
	}{
		{
			name:        "initialize CLI project",
			projectName: "my-cli",
			projectType: "cli",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil).   // go mod init
							ExpectAnyCommand(nil)          // template processing
			},
			expectErr: false,
		},
		{
			name:        "initialize web API project",
			projectName: "my-api",
			projectType: "api",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil).
							ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:        "initialize library project",
			projectName: "my-lib",
			projectType: "library",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", nil).
							ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:        "project initialization failure",
			projectName: "my-project",
			projectType: "cli",
			setupMock: func() {
				env.Builder.ExpectGoCommand("mod", assert.AnError) // go mod init fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Project()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitConfig(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful config initialization",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Config()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitGit(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful git initialization",
			setupMock: func() {
				env.Builder.ExpectGitCommand("init", "", nil).
							ExpectGitCommand("add", "", nil).
							ExpectGitCommand("commit", "", nil)
			},
			expectErr: false,
		},
		{
			name: "git init failure",
			setupMock: func() {
				env.Builder.ExpectGitCommand("init", "", assert.AnError) // git init fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Git()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitMage(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mage initialization",
			setupMock: func() {
				// File creation and template processing
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Mage()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitCI(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name     string
		provider string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "initialize GitHub Actions",
			provider: "github",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:     "initialize GitLab CI",
			provider: "gitlab",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:     "initialize Jenkins",
			provider: "jenkins",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:     "unsupported CI provider",
			provider: "unknown",
			setupMock: func() {
				// No mocks needed for validation error
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.CI()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitDocker(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		baseImage string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "initialize with Alpine base",
			baseImage: "alpine",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:      "initialize with scratch base",
			baseImage: "scratch",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:      "initialize with distroless base",
			baseImage: "distroless",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Docker()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitDocs(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		framework string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "initialize with MkDocs",
			framework: "mkdocs",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:      "initialize with GitBook",
			framework: "gitbook",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:      "initialize with Hugo",
			framework: "hugo",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:      "unsupported docs framework",
			framework: "unknown",
			setupMock: func() {
				// No mocks needed for validation error
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Docs()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitLicense(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		licenseType string
		author      string
		setupMock   func()
		expectErr   bool
	}{
		{
			name:        "initialize MIT license",
			licenseType: "MIT",
			author:      "John Doe",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:        "initialize Apache license",
			licenseType: "Apache-2.0",
			author:      "Jane Smith",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:        "initialize GPL license",
			licenseType: "GPL-3.0",
			author:      "Bob Johnson",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
		{
			name:        "unsupported license type",
			licenseType: "UNKNOWN",
			author:      "Test Author",
			setupMock: func() {
				// No mocks needed for validation error
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.License()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitMakefile(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful Makefile initialization",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Makefile()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestInitEditorConfig(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful .editorconfig initialization",
			setupMock: func() {
				// File creation doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			init := Init{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return init.Editorconfig()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
