package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestMonitorStart(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful monitor start",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // monitoring service start
			},
			expectErr: false,
		},
		{
			name: "monitor start failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // start fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Start()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorStop(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful monitor stop",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // monitoring service stop
			},
			expectErr: false,
		},
		{
			name: "monitor stop failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // stop fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Stop()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorStatus(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful status check",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // monitoring status check
			},
			expectErr: false,
		},
		{
			name: "status check failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // status check fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Status()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorLogs(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		service   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "view all logs",
			service: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // log viewer
			},
			expectErr: false,
		},
		{
			name:    "view specific service logs",
			service: "api",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:    "log viewing failure",
			service: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // log access fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Logs(tt.service)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorMetrics(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		timeRange string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "view recent metrics",
			timeRange: "1h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // metrics query
			},
			expectErr: false,
		},
		{
			name:      "view daily metrics",
			timeRange: "24h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:      "metrics query failure",
			timeRange: "1h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // query fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Metrics(tt.timeRange)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorAlerts(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "view active alerts",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // alert manager query
			},
			expectErr: false,
		},
		{
			name: "alert query failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // query fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Alerts()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorHealth(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		endpoint  string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "check default health endpoint",
			endpoint: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // health check
			},
			expectErr: false,
		},
		{
			name:     "check custom health endpoint",
			endpoint: "http://localhost:8080/health",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:     "health check failure",
			endpoint: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // health check fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Health(tt.endpoint)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorDashboard(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "start dashboard on default port",
			port: 3000,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // dashboard server
			},
			expectErr: false,
		},
		{
			name: "start dashboard on custom port",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name: "dashboard start failure",
			port: 3000,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Dashboard(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorTrace(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		traceID   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "view specific trace",
			traceID: "abc123def456",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // tracing query
			},
			expectErr: false,
		},
		{
			name:    "view recent traces",
			traceID: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:    "trace query failure",
			traceID: "invalid",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // query fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Trace(tt.traceID)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorProfile(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name        string
		profileType string
		duration    string
		setupMock   func()
		expectErr   bool
	}{
		{
			name:        "CPU profiling",
			profileType: "cpu",
			duration:    "30s",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // profiler
			},
			expectErr: false,
		},
		{
			name:        "memory profiling",
			profileType: "heap",
			duration:    "60s",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:        "profiling failure",
			profileType: "cpu",
			duration:    "30s",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // profiler fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Profile(tt.profileType, tt.duration)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestMonitorExport(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		format    string
		timeRange string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "export metrics as JSON",
			format:    "json",
			timeRange: "1h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // export tool
			},
			expectErr: false,
		},
		{
			name:      "export metrics as CSV",
			format:    "csv",
			timeRange: "24h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:      "export failure",
			format:    "json",
			timeRange: "1h",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // export fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			monitor := Monitor{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return monitor.Export(tt.format, tt.timeRange)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
