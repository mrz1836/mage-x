package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestReleaseCreate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")
	env.CreateMageConfig(`
project:
  name: testproject
  version: v1.0.0
`)

	tests := []struct {
		name      string
		version   string
		notes     string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "successful release creation",
			version: "v1.0.0",
			notes:   "Initial release",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", nil).
							ExpectGitCommand("push", "", nil).
							ExpectAnyCommand(nil) // github release creation
			},
			expectErr: false,
		},
		{
			name:    "release with detailed notes",
			version: "v1.1.0",
			notes:   "## Features\n- Add new API\n- Improve performance\n\n## Bug Fixes\n- Fix memory leak",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", nil).
							ExpectGitCommand("push", "", nil).
							ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:    "release creation failure",
			version: "v1.0.0",
			notes:   "Initial release",
			setupMock: func() {
				env.Builder.ExpectGitCommand("tag", "", assert.AnError) // tag creation fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Create()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleasePrepare(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")
	env.CreateMageConfig(`
project:
  name: testproject
  version: v1.0.0
`)

	tests := []struct {
		name      string
		version   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "successful release preparation",
			version: "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGoCommand("test", nil).      // run tests
							ExpectGoCommand("vet", nil).       // vet
							ExpectAnyCommand(nil).             // lint
							ExpectGoCommand("build", nil).     // build
							ExpectAnyCommand(nil)              // update version files
			},
			expectErr: false,
		},
		{
			name:    "preparation failure on tests",
			version: "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGoCommand("test", assert.AnError) // tests fail
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Prepare()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleasePublish(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		tag       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful release publish",
			tag:  "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("push", "", nil).     // push tag
							ExpectAnyCommand(nil).                 // build artifacts
							ExpectAnyCommand(nil)                  // publish to registry
			},
			expectErr: false,
		},
		{
			name: "publish failure",
			tag:  "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("push", "", assert.AnError) // push fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Publish()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseNotes(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		fromTag   string
		toTag     string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "generate release notes",
			fromTag: "v1.0.0",
			toTag:   "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("log", "commit abc123\ncommit def456", nil)
			},
			expectErr: false,
		},
		{
			name:    "release notes from beginning",
			fromTag: "",
			toTag:   "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("log", "commit abc123", nil)
			},
			expectErr: false,
		},
		{
			name:    "git log failure",
			fromTag: "v1.0.0",
			toTag:   "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("log", "", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Notes()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseValidate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		tag       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "valid release",
			tag:  "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "v1.0.0", nil).   // tag exists
							ExpectGoCommand("test", nil).                  // tests pass
							ExpectGoCommand("build", nil)                  // builds successfully
			},
			expectErr: false,
		},
		{
			name: "invalid tag format",
			tag:  "invalid-tag",
			setupMock: func() {
				// No mocks needed for validation error
			},
			expectErr: true,
		},
		{
			name: "tag does not exist",
			tag:  "v2.0.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("describe", "", assert.AnError) // tag doesn't exist
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Validate()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseClean(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create release artifacts
	env.CreateFile("dist/myapp-linux-amd64", "binary")
	env.CreateFile("dist/myapp-darwin-amd64", "binary")
	env.CreateFile("dist/myapp.tar.gz", "archive")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful clean",
			setupMock: func() {
				// File deletion doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Clean()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseArchive(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		version   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "successful archive creation",
			version: "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // tar/zip commands
			},
			expectErr: false,
		},
		{
			name:    "archive creation failure",
			version: "v1.0.0",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // tar fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Archive()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseUpload(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		tag       string
		assets    []string
		setupMock func()
		expectErr bool
	}{
		{
			name:   "successful upload",
			tag:    "v1.0.0",
			assets: []string{"dist/myapp-linux-amd64", "dist/myapp-darwin-amd64"},
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // github release upload
			},
			expectErr: false,
		},
		{
			name:   "upload with single asset",
			tag:    "v1.0.0",
			assets: []string{"dist/myapp.tar.gz"},
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // github release upload
			},
			expectErr: false,
		},
		{
			name:   "upload failure",
			tag:    "v1.0.0",
			assets: []string{"dist/nonexistent"},
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // upload fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.Upload(tt.tag, tt.assets...)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestReleaseList(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		limit     int
		setupMock func()
		expectErr bool
	}{
		{
			name:  "list all releases",
			limit: 0,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // github release list
			},
			expectErr: false,
		},
		{
			name:  "list recent releases",
			limit: 10,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // github release list
			},
			expectErr: false,
		},
		{
			name:  "list failure",
			limit: 0,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // api call fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			release := Release{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return release.List(tt.limit)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
