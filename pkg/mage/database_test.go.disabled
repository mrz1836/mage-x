package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestDatabaseMigrate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create migration files
	env.CreateFile("migrations/001_create_users.sql", `CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);`)

	tests := []struct {
		name      string
		direction string
		setupMock func()
		expectErr bool
	}{
		{
			name:      "migrate up",
			direction: "up",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // migration tool
			},
			expectErr: false,
		},
		{
			name:      "migrate down",
			direction: "down",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // migration tool
			},
			expectErr: false,
		},
		{
			name:      "migration failure",
			direction: "up",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // migration fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Migrate(tt.direction)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseSeed(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create seed files
	env.CreateFile("seeds/users.sql", `INSERT INTO users (name, email) VALUES
('John Doe', 'john@example.com'),
('Jane Smith', 'jane@example.com');`)

	tests := []struct {
		name      string
		seedName  string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "seed all",
			seedName: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // seed runner
			},
			expectErr: false,
		},
		{
			name:     "seed specific table",
			seedName: "users",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // seed runner
			},
			expectErr: false,
		},
		{
			name:     "seed failure",
			seedName: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // seed fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Seed(tt.seedName)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseReset(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful reset",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil). // drop database
							ExpectAnyCommand(nil). // create database
							ExpectAnyCommand(nil)  // run migrations
			},
			expectErr: false,
		},
		{
			name: "reset failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // drop fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Reset()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseBackup(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name       string
		backupFile string
		setupMock  func()
		expectErr  bool
	}{
		{
			name:       "successful backup",
			backupFile: "backup.sql",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // pg_dump or mysqldump
			},
			expectErr: false,
		},
		{
			name:       "backup with timestamp",
			backupFile: "",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // backup with auto-generated name
			},
			expectErr: false,
		},
		{
			name:       "backup failure",
			backupFile: "backup.sql",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // backup fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Backup(tt.backupFile)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseRestore(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create backup file
	env.CreateFile("backup.sql", "-- Database backup\nCREATE TABLE test (id INT);")

	tests := []struct {
		name       string
		backupFile string
		setupMock  func()
		expectErr  bool
	}{
		{
			name:       "successful restore",
			backupFile: "backup.sql",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // psql or mysql restore
			},
			expectErr: false,
		},
		{
			name:       "restore failure",
			backupFile: "nonexistent.sql",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // restore fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Restore(tt.backupFile)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseStatus(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful status check",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // migration status check
			},
			expectErr: false,
		},
		{
			name: "status check failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // status check fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Status()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseCreate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name       string
		dbName     string
		setupMock  func()
		expectErr  bool
	}{
		{
			name:   "create database",
			dbName: "testdb",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // createdb or CREATE DATABASE
			},
			expectErr: false,
		},
		{
			name:   "create database failure",
			dbName: "testdb",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // create fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Create(tt.dbName)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseDrop(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		dbName    string
		setupMock func()
		expectErr bool
	}{
		{
			name:   "drop database",
			dbName: "testdb",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // dropdb or DROP DATABASE
			},
			expectErr: false,
		},
		{
			name:   "drop database failure",
			dbName: "testdb",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // drop fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Drop(tt.dbName)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseConsole(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful console access",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // psql or mysql client
			},
			expectErr: false,
		},
		{
			name: "console access failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // console fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Console()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDatabaseQuery(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		query     string
		setupMock func()
		expectErr bool
	}{
		{
			name:  "execute select query",
			query: "SELECT * FROM users;",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // database query execution
			},
			expectErr: false,
		},
		{
			name:  "execute insert query",
			query: "INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name:  "query execution failure",
			query: "INVALID SQL;",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // query fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			database := Database{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return database.Query(tt.query)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
