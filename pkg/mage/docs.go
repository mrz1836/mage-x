// Package mage provides reusable build tasks for Go projects using Mage
package mage

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"

	"github.com/magefile/mage/mg"
	"github.com/mrz1836/go-mage/pkg/common/fileops"
	"github.com/mrz1836/go-mage/pkg/utils"
)

// Docs namespace for documentation-related tasks
type Docs mg.Namespace

// Citation updates version in CITATION.cff (use version=X.Y.Z)
func (Docs) Citation() error {
	version := os.Getenv("version")
	if version == "" {
		return fmt.Errorf("version variable is required. Use: version=X.Y.Z mage docs:citation")
	}

	utils.Header("Updating CITATION.cff Version")

	// Check if CITATION.cff exists
	if !utils.FileExists("CITATION.cff") {
		return fmt.Errorf("CITATION.cff file not found")
	}

	// Read the file
	fileOps := fileops.New()
	content, err := fileOps.File.ReadFile("CITATION.cff")
	if err != nil {
		return fmt.Errorf("failed to read CITATION.cff: %w", err)
	}

	// Update version line
	versionRegex := regexp.MustCompile(`(?m)^version: ".*"$`)
	newContent := versionRegex.ReplaceAllString(string(content), fmt.Sprintf(`version: "%s"`, version))

	// Check if replacement was made
	if string(content) == newContent {
		utils.Warn("No version line found in CITATION.cff")
		return fmt.Errorf("could not find version line to update")
	}

	// Write back
	if err := fileOps.File.WriteFile("CITATION.cff", []byte(newContent), 0o644); err != nil {
		return fmt.Errorf("failed to write CITATION.cff: %w", err)
	}

	utils.Success("Updated CITATION.cff version to %s", version)
	return nil
}

// GoDocs triggers pkg.go.dev sync
func (Docs) GoDocs() error {
	utils.Header("Syndicating to pkg.go.dev")

	cfg, err := GetConfig()
	if err != nil {
		return err
	}

	// Construct module path
	module := cfg.Project.Module
	if module == "" {
		module, err = utils.GetModuleName()
		if err != nil {
			return fmt.Errorf("failed to get module name: %w", err)
		}
	}

	// Get latest version
	version := getVersion()
	if version == "dev" {
		utils.Warn("No version tag found, using latest")
		version = "latest"
	}

	// Construct pkg.go.dev URL
	proxyURL := fmt.Sprintf("https://proxy.golang.org/%s/@v/%s.info", module, version)

	utils.Info("Triggering sync for %s@%s", module, version)

	// Use curl to trigger the proxy
	output, err := GetRunner().RunCmdOutput("curl", "-sSf", proxyURL)
	if err != nil {
		return fmt.Errorf("failed to trigger pkg.go.dev sync: %w", err)
	}

	utils.Success("Successfully triggered pkg.go.dev sync")
	utils.Info("Response: %s", strings.TrimSpace(output))
	utils.Info("View at: https://pkg.go.dev/%s", module)

	return nil
}

// Generate generates Go documentation
func (Docs) Generate() error {
	utils.Header("Generating Go Documentation")

	// Check if we have a docs directory
	docsDir := "docs"
	fileOps := fileops.New()
	if !utils.DirExists(docsDir) {
		utils.Info("Creating docs directory...")
		if err := fileOps.File.MkdirAll(docsDir, 0o755); err != nil {
			return fmt.Errorf("failed to create docs directory: %w", err)
		}
	}

	// Generate package documentation
	output, err := GetRunner().RunCmdOutput("go", "doc", "-all", ".")
	if err != nil {
		return fmt.Errorf("failed to generate documentation: %w", err)
	}

	// Write to file
	docFile := filepath.Join(docsDir, "package.md")
	content := fmt.Sprintf("# Package Documentation\n\nGenerated by `go doc -all`\n\n```\n%s\n```\n", output)

	if err := fileOps.File.WriteFile(docFile, []byte(content), 0o644); err != nil {
		return fmt.Errorf("failed to write documentation: %w", err)
	}

	utils.Success("Documentation generated in %s", docFile)
	return nil
}

// ServeDefault starts a local godoc server on default port
func (Docs) ServeDefault() error {
	return Docs{}.Serve()
}

// Serve serves documentation locally
func (Docs) Serve() error {
	actualPort := 6060
	utils.Header("Starting Documentation Server")

	// Check if godoc is installed
	if !utils.CommandExists("godoc") {
		utils.Info("Installing godoc...")
		if err := GetRunner().RunCmd("go", "install", "golang.org/x/tools/cmd/godoc@latest"); err != nil {
			return fmt.Errorf("failed to install godoc: %w", err)
		}
	}

	portStr := fmt.Sprintf("%d", actualPort)
	utils.Info("Starting godoc server on http://localhost:%s", portStr)
	utils.Info("Press Ctrl+C to stop")

	// Open browser after a short delay
	go func() {
		utils.Info("Opening browser...")

		url := fmt.Sprintf("http://localhost:%s", portStr)

		switch runtime.GOOS {
		case "darwin":
			GetRunner().RunCmd("open", url)
		case "linux":
			GetRunner().RunCmd("xdg-open", url)
		case "windows":
			GetRunner().RunCmd("cmd", "/c", "start", url)
		}
	}()

	// Start godoc server
	return GetRunner().RunCmd("godoc", "-http", ":"+portStr)
}

// Check validates documentation
func (Docs) Check() error {
	utils.Header("Checking Documentation")

	issues := []string{}

	// Check README.md
	if !utils.FileExists("README.md") {
		issues = append(issues, "README.md is missing")
	}

	// Check LICENSE
	if !utils.FileExists("LICENSE") {
		issues = append(issues, "LICENSE file is missing")
	}

	// Check CONTRIBUTING.md
	if !utils.FileExists("CONTRIBUTING.md") {
		utils.Warn("CONTRIBUTING.md is missing (recommended)")
	}

	// Check SECURITY.md
	if !utils.FileExists("SECURITY.md") {
		utils.Warn("SECURITY.md is missing (recommended)")
	}

	// Check package comments
	utils.Info("Checking package documentation...")
	output, err := GetRunner().RunCmdOutput("go", "list", "-f", "{{.Doc}}", "./...")
	if err != nil {
		utils.Warn("Failed to check package documentation: %v", err)
	} else {
		packages := strings.Split(strings.TrimSpace(output), "\n")
		for i, doc := range packages {
			if strings.TrimSpace(doc) == "" {
				utils.Warn("Package %d is missing documentation comment", i+1)
			}
		}
	}

	// Check for example files
	examples, _ := utils.FindFiles(".", "example*.go")
	if len(examples) == 0 {
		utils.Info("No example files found (consider adding examples)")
	} else {
		utils.Success("Found %d example file(s)", len(examples))
	}

	if len(issues) > 0 {
		utils.Error("Documentation issues found:")
		for _, issue := range issues {
			fmt.Printf("  - %s\n", issue)
		}
		return fmt.Errorf("documentation check failed")
	}

	utils.Success("Documentation check passed")
	return nil
}

// Examples generates example documentation
func (Docs) Examples() error {
	utils.Header("Generating Example Documentation")

	// Find all example files
	examples, err := utils.FindFiles(".", "example*.go")
	if err != nil {
		return fmt.Errorf("failed to find examples: %w", err)
	}

	if len(examples) == 0 {
		utils.Warn("No example files found")
		return nil
	}

	// Create examples documentation
	var content strings.Builder
	content.WriteString("# Examples\n\n")

	for _, example := range examples {
		utils.Info("Processing %s", example)

		// Read example file
		fileOps := fileops.New()
		code, err := fileOps.File.ReadFile(example)
		if err != nil {
			utils.Warn("Failed to read %s: %v", example, err)
			continue
		}

		// Extract example name from filename
		name := filepath.Base(example)
		name = strings.TrimSuffix(name, ".go")
		name = strings.TrimPrefix(name, "example_")

		// Add to documentation
		content.WriteString(fmt.Sprintf("## %s\n\n", name))
		content.WriteString("```go\n")
		content.WriteString(string(code))
		content.WriteString("\n```\n\n")
	}

	// Write examples documentation
	examplesFile := "EXAMPLES.md"
	fileOps := fileops.New()
	if err := fileOps.File.WriteFile(examplesFile, []byte(content.String()), 0o644); err != nil {
		return fmt.Errorf("failed to write examples documentation: %w", err)
	}

	utils.Success("Generated %s with %d examples", examplesFile, len(examples))
	return nil
}

// Default generates default documentation
func (Docs) Default() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Generating default documentation")
}

// Build builds the documentation
func (Docs) Build() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Building documentation")
}

// Lint lints the documentation
func (Docs) Lint() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Linting documentation")
}

// Spell checks spelling in documentation
func (Docs) Spell() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Spell checking documentation")
}

// Links checks links in documentation
func (Docs) Links() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Checking documentation links")
}

// API generates API documentation
func (Docs) API() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Generating API documentation")
}

// Markdown generates Markdown documentation
func (Docs) Markdown() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Generating Markdown documentation")
}

// Readme generates README documentation
func (Docs) Readme() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Generating README")
}

// Changelog generates changelog documentation
func (Docs) Changelog(version string) error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Generating changelog for version:", version)
}

// Clean cleans documentation build artifacts
func (Docs) Clean() error {
	runner := GetRunner()
	return runner.RunCmd("echo", "Cleaning documentation")
}
