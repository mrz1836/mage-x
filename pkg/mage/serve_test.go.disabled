package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestServeHTTP(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful HTTP serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run main.go
			},
			expectErr: false,
		},
		{
			name: "HTTP serve on custom port",
			port: 3000,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil)
			},
			expectErr: false,
		},
		{
			name: "HTTP serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.HTTP(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeHTTPS(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create SSL certificates
	env.CreateFile("certs/server.crt", "-----BEGIN CERTIFICATE-----")
	env.CreateFile("certs/server.key", "-----BEGIN PRIVATE KEY-----")

	tests := []struct {
		name      string
		port      int
		certFile  string
		keyFile   string
		setupMock func()
		expectErr bool
	}{
		{
			name:     "successful HTTPS serve",
			port:     8443,
			certFile: "certs/server.crt",
			keyFile:  "certs/server.key",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // go run with TLS
			},
			expectErr: false,
		},
		{
			name:     "HTTPS serve failure",
			port:     8443,
			certFile: "certs/server.crt",
			keyFile:  "certs/server.key",
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // TLS server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.HTTPS(tt.port, tt.certFile, tt.keyFile)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeDocs(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create documentation
	env.CreateFile("docs/index.html", "<html><body>Documentation</body></html>")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful docs serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // documentation server
			},
			expectErr: false,
		},
		{
			name: "docs serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // docs server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.Docs(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeAPI(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful API serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // API server
			},
			expectErr: false,
		},
		{
			name: "API serve with custom port",
			port: 9000,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil)
			},
			expectErr: false,
		},
		{
			name: "API serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // API server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.API(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeGRPC(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful gRPC serve",
			port: 9090,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // gRPC server
			},
			expectErr: false,
		},
		{
			name: "gRPC serve failure",
			port: 9090,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // gRPC server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.GRPC(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeMetrics(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful metrics serve",
			port: 9090,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // metrics server
			},
			expectErr: false,
		},
		{
			name: "metrics serve failure",
			port: 9090,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // metrics server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.Metrics(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeStatic(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create static files
	env.CreateFile("static/index.html", "<html><body>Static Site</body></html>")
	env.CreateFile("static/style.css", "body { margin: 0; }")

	tests := []struct {
		name      string
		port      int
		dir       string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful static serve",
			port: 8080,
			dir:  "static",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // static file server
			},
			expectErr: false,
		},
		{
			name: "static serve with custom directory",
			port: 3000,
			dir:  "public",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil)
			},
			expectErr: false,
		},
		{
			name: "static serve failure",
			port: 8080,
			dir:  "static",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.Static(tt.port, tt.dir)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeProxy(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		target    string
		setupMock func()
		expectErr bool
	}{
		{
			name:   "successful proxy serve",
			port:   8080,
			target: "http://localhost:9000",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // proxy server
			},
			expectErr: false,
		},
		{
			name:   "proxy serve failure",
			port:   8080,
			target: "http://localhost:9000",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // proxy fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.Proxy(tt.port, tt.target)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeWebSocket(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful WebSocket serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // WebSocket server
			},
			expectErr: false,
		},
		{
			name: "WebSocket serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // WebSocket server fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.WebSocket(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestServeHealthCheck(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful health check serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", nil) // health check server
			},
			expectErr: false,
		},
		{
			name: "health check serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectGoCommand("run", assert.AnError) // health check fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			serve := Serve{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return serve.HealthCheck(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
