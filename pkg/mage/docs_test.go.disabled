package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestDocsGenerate(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful docs generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // godoc or similar
			},
			expectErr: false,
		},
		{
			name: "docs generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // doc generation fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Generate()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsServe(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		port      int
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful docs serve",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // godoc -http
			},
			expectErr: false,
		},
		{
			name: "docs serve on custom port",
			port: 9090,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // godoc -http
			},
			expectErr: false,
		},
		{
			name: "docs serve failure",
			port: 8080,
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // serve fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Serve(tt.port)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsBuild(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create source documentation
	env.CreateFile("docs/README.md", "# Documentation")
	env.CreateFile("docs/api.md", "# API Reference")

	tests := []struct {
		name      string
		format    string
		setupMock func()
		expectErr bool
	}{
		{
			name:   "build HTML docs",
			format: "html",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // markdown to html
			},
			expectErr: false,
		},
		{
			name:   "build PDF docs",
			format: "pdf",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // markdown to pdf
			},
			expectErr: false,
		},
		{
			name:   "docs build failure",
			format: "html",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // build fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Build(tt.format)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsLint(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create documentation files
	env.CreateFile("README.md", "# Project\n\nThis is a test project.")
	env.CreateFile("docs/guide.md", "# User Guide\n\nFollow these steps...")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "docs pass linting",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // markdownlint
			},
			expectErr: false,
		},
		{
			name: "docs linting issues",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // linting issues found
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Lint()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsSpell(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create documentation with potential spelling issues
	env.CreateFile("README.md", "# Projekt\n\nThis is a tset project.")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "no spelling errors",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // spellchecker
			},
			expectErr: false,
		},
		{
			name: "spelling errors found",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // spelling issues
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Spell()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsLinks(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create documentation with links
	env.CreateFile("README.md", `# Project

Visit [our website](https://example.com) for more info.
See also [API docs](./docs/api.md).
`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "all links valid",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // link checker
			},
			expectErr: false,
		},
		{
			name: "broken links found",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // broken links
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Links()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsAPI(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create Go files with doc comments
	env.CreateFile("api.go", `package main

// UserService provides user management functionality.
type UserService struct {}

// GetUser retrieves a user by ID.
func (s *UserService) GetUser(id string) (*User, error) {
	return nil, nil
}

// User represents a user in the system.
type User struct {
	ID   string ` + "`json:\"id\"`" + `
	Name string ` + "`json:\"name\"`" + `
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful API docs generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // go doc or similar
			},
			expectErr: false,
		},
		{
			name: "API docs generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // generation fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.API()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsReadme(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")
	env.CreateMageConfig(`
project:
  name: testproject
  description: A test project
  version: v1.0.0
`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful README generation",
			setupMock: func() {
				// Template processing doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Readme()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsChangelog(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		version   string
		setupMock func()
		expectErr bool
	}{
		{
			name:    "generate changelog",
			version: "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("log", "commit abc123\ncommit def456", nil)
			},
			expectErr: false,
		},
		{
			name:    "changelog generation failure",
			version: "v1.1.0",
			setupMock: func() {
				env.Builder.ExpectGitCommand("log", "", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Changelog(tt.version)
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestDocsClean(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create generated documentation
	env.CreateFile("docs/generated/api.html", "generated docs")
	env.CreateFile("site/index.html", "built site")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful docs clean",
			setupMock: func() {
				// File deletion doesn't require external commands
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			docs := Docs{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return docs.Clean()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
