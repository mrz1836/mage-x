package mage

import (
	"testing"

	"github.com/mrz1836/go-mage/pkg/mage/testutil"
	"github.com/stretchr/testify/assert"
)

func TestGenerateAll(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful generate all",
			setupMock: func() {
				env.Builder.ExpectGoCommand("generate", nil)
			},
			expectErr: false,
		},
		{
			name: "generate failure",
			setupMock: func() {
				env.Builder.ExpectGoCommand("generate", assert.AnError)
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.All()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateMocks(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create interface file
	env.CreateFile("interfaces.go", `package main

//go:generate mockgen -source=interfaces.go -destination=mocks/interfaces.go

type UserService interface {
	GetUser(id string) (*User, error)
	CreateUser(user *User) error
}

type User struct {
	ID   string
	Name string
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful mock generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // mockgen
			},
			expectErr: false,
		},
		{
			name: "mock generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // mockgen fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Mocks()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateDocs(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful docs generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // godoc or similar
			},
			expectErr: false,
		},
		{
			name: "docs generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // doc generation fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Docs()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateSwagger(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create API file with swagger annotations
	env.CreateFile("api.go", `package main

// @title Test API
// @version 1.0
// @description This is a test API

//go:generate swag init

import "github.com/gin-gonic/gin"

// @Summary Get user
// @Tags users
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} User
// @Router /users/{id} [get]
func getUser(c *gin.Context) {
	// implementation
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful swagger generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // swag init
			},
			expectErr: false,
		},
		{
			name: "swagger generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // swag fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Swagger()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateProto(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create proto file
	env.CreateFile("api/user.proto", `syntax = "proto3";

package api;

option go_package = "./;api";

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

message GetUserRequest {
  string id = 1;
}

message GetUserResponse {
  User user = 1;
}

message CreateUserRequest {
  User user = 1;
}

message CreateUserResponse {
  User user = 1;
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful proto generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // protoc
			},
			expectErr: false,
		},
		{
			name: "proto generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // protoc fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Proto()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateOpenAPI(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create OpenAPI spec
	env.CreateFile("api/openapi.yaml", `openapi: 3.0.0
info:
  title: Test API
  version: 1.0.0
paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: User found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        email:
          type: string`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful openapi generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // openapi-generator
			},
			expectErr: false,
		},
		{
			name: "openapi generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // generator fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.OpenAPI()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateSQL(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create SQL schema
	env.CreateFile("schema.sql", `-- name: GetUser :one
SELECT * FROM users WHERE id = $1;

-- name: ListUsers :many
SELECT * FROM users ORDER BY name;

-- name: CreateUser :one
INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *;

-- name: UpdateUser :exec
UPDATE users SET name = $1, email = $2 WHERE id = $3;

-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1;`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful sql generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // sqlc generate
			},
			expectErr: false,
		},
		{
			name: "sql generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // sqlc fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.SQL()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateWire(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create wire definitions
	env.CreateFile("wire.go", `//go:build wireinject
// +build wireinject

package main

import "github.com/google/wire"

//go:generate wire

func InitializeApp() (*App, error) {
	wire.Build(
		NewDatabase,
		NewUserService,
		NewApp,
	)
	return &App{}, nil
}`)

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful wire generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // wire
			},
			expectErr: false,
		},
		{
			name: "wire generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // wire fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Wire()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateConfig(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful config generation",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(nil) // config generator
			},
			expectErr: false,
		},
		{
			name: "config generation failure",
			setupMock: func() {
				env.Builder.ExpectAnyCommand(assert.AnError) // generator fails
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Config()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}

func TestGenerateClean(t *testing.T) {
	env := testutil.NewTestEnvironment(t)
	defer env.Cleanup()

	env.CreateProjectStructure()
	env.CreateGoMod("github.com/test/project")

	// Create some generated files
	env.CreateFile("generated/mock.go", "// Code generated by mockgen")
	env.CreateFile("docs/swagger.json", "{}")

	tests := []struct {
		name      string
		setupMock func()
		expectErr bool
	}{
		{
			name: "successful clean generated files",
			setupMock: func() {
				// No external commands needed for file deletion
			},
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setupMock()

			generate := Generate{}
			err := env.WithMockRunner(
				func(r interface{}) { SetRunner(r.(CommandRunner)) },
				func() interface{} { return GetRunner() },
				func() error {
					return generate.Clean()
				},
			)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			env.Runner.AssertExpectations(t)
		})
	}
}
